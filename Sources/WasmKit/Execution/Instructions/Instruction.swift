// swift-format-ignore-file
//// Automatically generated by Utilities/Sources/VMGen.swift
//// DO NOT EDIT DIRECTLY

/// An internal VM instruction.
///
/// NOTE: This enum representation is just for modeling purposes. The actual
/// runtime representation can be different.
enum Instruction: Equatable {
    /// Copy a register value to another register
    case copyStack(Instruction.CopyStackOperand)
    /// WebAssembly Core Instruction `global.get`
    case globalGet(Instruction.GlobalAndVRegOperand)
    /// WebAssembly Core Instruction `global.set`
    case globalSet(Instruction.GlobalAndVRegOperand)
    /// WebAssembly Core Instruction `call`
    case call(Instruction.CallOperand)
    /// Compile a callee function (if not compiled) and call it.
    /// 
    /// This instruction is replaced by `internalCall` after the callee is compiled.
    case compilingCall(Instruction.CallOperand)
    /// Call a function defined in the current module
    /// 
    /// This instruction can skip switching the current instance.
    case internalCall(Instruction.CallOperand)
    /// WebAssembly Core Instruction `call_indirect`
    case callIndirect(Instruction.CallIndirectOperand)
    /// Resize the frame header by increasing param/result slots and copying `sizeToCopy`
    /// slots placed after the header
    case resizeFrameHeader(Instruction.ResizeFrameHeaderOperand)
    /// WebAssembly Core Instruction `return_call`
    case returnCall(Instruction.ReturnCallOperand)
    /// WebAssembly Core Instruction `return_call_indirect`
    case returnCallIndirect(Instruction.ReturnCallIndirectOperand)
    /// WebAssembly Core Instruction `unreachable`
    case unreachable
    /// WebAssembly Core Instruction `nop`
    case nop
    /// Unconditional pc-relative branch
    case br(Instruction.BrOperand)
    /// Conditional pc-relative branch if the condition is true
    case brIf(Instruction.BrIfOperand)
    /// Conditional pc-relative branch if the condition is false
    case brIfNot(Instruction.BrIfOperand)
    /// WebAssembly Core Instruction `br_table`
    case brTable(Instruction.BrTableOperand)
    /// Return from a function
    case _return
    /// End the execution of the VM
    /// 
    /// This instruction is used to signal the end of the execution of the VM at
    /// the root frame.
    case endOfExecution
    /// WebAssembly Core Instruction `i32.load`
    case i32Load(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load`
    case i64Load(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `f32.load`
    case f32Load(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `f64.load`
    case f64Load(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.load8_s`
    case i32Load8S(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.load8_u`
    case i32Load8U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.load16_s`
    case i32Load16S(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.load16_u`
    case i32Load16U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load8_s`
    case i64Load8S(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load8_u`
    case i64Load8U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load16_s`
    case i64Load16S(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load16_u`
    case i64Load16U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load32_s`
    case i64Load32S(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.load32_u`
    case i64Load32U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.store`
    case i32Store(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.store`
    case i64Store(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `f32.store`
    case f32Store(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `f64.store`
    case f64Store(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i32.store8`
    case i32Store8(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i32.store16`
    case i32Store16(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.store8`
    case i64Store8(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.store16`
    case i64Store16(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.store32`
    case i64Store32(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `memory.size`
    case memorySize(Instruction.MemorySizeOperand)
    /// WebAssembly Core Instruction `memory.grow`
    case memoryGrow(Instruction.MemoryGrowOperand)
    /// WebAssembly Core Instruction `memory.init`
    case memoryInit(Instruction.MemoryInitOperand)
    /// WebAssembly Core Instruction `memory.drop`
    case memoryDataDrop(Instruction.MemoryDataDropOperand)
    /// WebAssembly Core Instruction `memory.copy`
    case memoryCopy(Instruction.MemoryCopyOperand)
    /// WebAssembly Core Instruction `memory.fill`
    case memoryFill(Instruction.MemoryFillOperand)
    /// WebAssembly SIMD Instruction `v128.const`
    case v128Const(Instruction.V128ConstOperand)
    /// WebAssembly SIMD Instruction `i8x16.shuffle`
    case i8x16Shuffle(Instruction.I8x16ShuffleOperand)
    /// WebAssembly SIMD instruction (runtime-dispatched)
    case simd(Instruction.SimdOperand)
    /// Assign a 32-bit constant to a register
    case const32(Instruction.Const32Operand)
    /// Assign a 64-bit constant to a register
    case const64(Instruction.Const64Operand)
    /// WebAssembly Core Instruction `i32.add`
    case i32Add(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.add`
    case i64Add(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.sub`
    case i32Sub(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.sub`
    case i64Sub(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.mul`
    case i32Mul(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.mul`
    case i64Mul(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.and`
    case i32And(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.and`
    case i64And(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.or`
    case i32Or(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.or`
    case i64Or(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.xor`
    case i32Xor(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.xor`
    case i64Xor(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.shl`
    case i32Shl(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.shl`
    case i64Shl(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.shr_s`
    case i32ShrS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.shr_s`
    case i64ShrS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.shr_u`
    case i32ShrU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.shr_u`
    case i64ShrU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.rotl`
    case i32Rotl(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.rotl`
    case i64Rotl(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.rotr`
    case i32Rotr(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.rotr`
    case i64Rotr(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.div_s`
    case i32DivS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.div_s`
    case i64DivS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.div_u`
    case i32DivU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.div_u`
    case i64DivU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.rem_s`
    case i32RemS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.rem_s`
    case i64RemS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.rem_u`
    case i32RemU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.rem_u`
    case i64RemU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.eq`
    case i32Eq(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.eq`
    case i64Eq(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.ne`
    case i32Ne(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.ne`
    case i64Ne(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.lt_s`
    case i32LtS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.lt_s`
    case i64LtS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.lt_u`
    case i32LtU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.lt_u`
    case i64LtU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.gt_s`
    case i32GtS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.gt_s`
    case i64GtS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.gt_u`
    case i32GtU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.gt_u`
    case i64GtU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.le_s`
    case i32LeS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.le_s`
    case i64LeS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.le_u`
    case i32LeU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.le_u`
    case i64LeU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.ge_s`
    case i32GeS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.ge_s`
    case i64GeS(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.ge_u`
    case i32GeU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i64.ge_u`
    case i64GeU(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `i32.clz`
    case i32Clz(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.clz`
    case i64Clz(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.ctz`
    case i32Ctz(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.ctz`
    case i64Ctz(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.popcnt`
    case i32Popcnt(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.popcnt`
    case i64Popcnt(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.eqz`
    case i32Eqz(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.eqz`
    case i64Eqz(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.wrap`
    case i32WrapI64(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.extend_i32_s`
    case i64ExtendI32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.extend_i32_u`
    case i64ExtendI32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.extend8_s`
    case i32Extend8S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.extend8_s`
    case i64Extend8S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.extend16_s`
    case i32Extend16S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.extend16_s`
    case i64Extend16S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.extend32_s`
    case i64Extend32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_to_i32_s`
    case i32TruncF32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_to_i32_u`
    case i32TruncF32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_sat_to_i32_s`
    case i32TruncSatF32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_sat_to_i32_u`
    case i32TruncSatF32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_to_i32_s`
    case i32TruncF64S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_to_i32_u`
    case i32TruncF64U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_sat_to_i32_s`
    case i32TruncSatF64S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_sat_to_i32_u`
    case i32TruncSatF64U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_to_i64_s`
    case i64TruncF32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_to_i64_u`
    case i64TruncF32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_sat_to_i64_s`
    case i64TruncSatF32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc_sat_to_i64_u`
    case i64TruncSatF32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_to_i64_s`
    case i64TruncF64S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_to_i64_u`
    case i64TruncF64U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_sat_to_i64_s`
    case i64TruncSatF64S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc_sat_to_i64_u`
    case i64TruncSatF64U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.convert_to_f32_s`
    case f32ConvertI32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.convert_to_f32_u`
    case f32ConvertI32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.convert_to_f32_s`
    case f32ConvertI64S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.convert_to_f32_u`
    case f32ConvertI64U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.convert_to_f64_s`
    case f64ConvertI32S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.convert_to_f64_u`
    case f64ConvertI32U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.convert_to_f64_s`
    case f64ConvertI64S(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.convert_to_f64_u`
    case f64ConvertI64U(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i32.reinterpret_to_f32`
    case f32ReinterpretI32(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `i64.reinterpret_to_f64`
    case f64ReinterpretI64(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.reinterpret_to_i32`
    case i32ReinterpretF32(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.reinterpret_to_i64`
    case i64ReinterpretF64(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.add`
    case f32Add(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.add`
    case f64Add(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.sub`
    case f32Sub(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.sub`
    case f64Sub(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.mul`
    case f32Mul(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.mul`
    case f64Mul(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.div`
    case f32Div(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.div`
    case f64Div(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.min`
    case f32Min(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.min`
    case f64Min(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.max`
    case f32Max(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.max`
    case f64Max(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.copy_sign`
    case f32CopySign(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.copy_sign`
    case f64CopySign(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.eq`
    case f32Eq(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.eq`
    case f64Eq(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.ne`
    case f32Ne(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.ne`
    case f64Ne(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.lt`
    case f32Lt(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.lt`
    case f64Lt(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.gt`
    case f32Gt(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.gt`
    case f64Gt(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.le`
    case f32Le(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.le`
    case f64Le(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.ge`
    case f32Ge(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f64.ge`
    case f64Ge(Instruction.BinaryOperand)
    /// WebAssembly Core Instruction `f32.abs`
    case f32Abs(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.abs`
    case f64Abs(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.neg`
    case f32Neg(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.neg`
    case f64Neg(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.ceil`
    case f32Ceil(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.ceil`
    case f64Ceil(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.floor`
    case f32Floor(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.floor`
    case f64Floor(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.trunc`
    case f32Trunc(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.trunc`
    case f64Trunc(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.nearest`
    case f32Nearest(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.nearest`
    case f64Nearest(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.sqrt`
    case f32Sqrt(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.sqrt`
    case f64Sqrt(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f32.promote_f32`
    case f64PromoteF32(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `f64.demote_f64`
    case f32DemoteF64(Instruction.UnaryOperand)
    /// WebAssembly Core Instruction `select`
    case select(Instruction.SelectOperand)
    /// WebAssembly Core Instruction `ref.null`
    case refNull(Instruction.RefNullOperand)
    /// WebAssembly Core Instruction `ref.is_null`
    case refIsNull(Instruction.RefIsNullOperand)
    /// WebAssembly Core Instruction `ref.func`
    case refFunc(Instruction.RefFuncOperand)
    /// WebAssembly Core Instruction `table.get`
    case tableGet(Instruction.TableGetOperand)
    /// WebAssembly Core Instruction `table.set`
    case tableSet(Instruction.TableSetOperand)
    /// WebAssembly Core Instruction `table.size`
    case tableSize(Instruction.TableSizeOperand)
    /// WebAssembly Core Instruction `table.grow`
    case tableGrow(Instruction.TableGrowOperand)
    /// WebAssembly Core Instruction `table.fill`
    case tableFill(Instruction.TableFillOperand)
    /// WebAssembly Core Instruction `table.copy`
    case tableCopy(Instruction.TableCopyOperand)
    /// WebAssembly Core Instruction `table.init`
    case tableInit(Instruction.TableInitOperand)
    /// WebAssembly Core Instruction `table.drop`
    case tableElementDrop(Instruction.TableElementDropOperand)
    /// Intercept the entry of a function
    case onEnter(Instruction.OnEnterOperand)
    /// Intercept the exit of a function
    case onExit(Instruction.OnExitOperand)
    /// Stop the VM on this instruction as a breakpoint
    /// 
    /// This instruction is used in debugging scenarios.
    case breakpoint
    /// WebAssembly Core Instruction `i32.atomic.load`
    case i32AtomicLoad(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.atomic.load`
    case i64AtomicLoad(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.atomic.load8_u`
    case i32AtomicLoad8U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.atomic.load16_u`
    case i32AtomicLoad16U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.atomic.load8_u`
    case i64AtomicLoad8U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.atomic.load16_u`
    case i64AtomicLoad16U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i64.atomic.load32_u`
    case i64AtomicLoad32U(Instruction.LoadOperand)
    /// WebAssembly Core Instruction `i32.atomic.store`
    case i32AtomicStore(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.atomic.store`
    case i64AtomicStore(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i32.atomic.store8`
    case i32AtomicStore8(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i32.atomic.store16`
    case i32AtomicStore16(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.atomic.store8`
    case i64AtomicStore8(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.atomic.store16`
    case i64AtomicStore16(Instruction.StoreOperand)
    /// WebAssembly Core Instruction `i64.atomic.store32`
    case i64AtomicStore32(Instruction.StoreOperand)
}

extension Instruction {
    // MARK: - Instruction Immediates

    struct CopyStackOperand: Equatable, InstructionImmediate {
        var source: LVReg
        var dest: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (source, dest) = pc.read((LVReg, LVReg).self)
            return Self(source: source, dest: dest)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.source, $0.dest) as (LVReg, LVReg), to: CodeSlot.self) }
        }
    }

    struct GlobalAndVRegOperand: Equatable, InstructionImmediate {
        var reg: LLVReg
        var rawGlobal: UInt64
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (reg) = pc.read((LLVReg).self)
            let (rawGlobal) = pc.read((UInt64).self)
            return Self(reg: reg, rawGlobal: rawGlobal)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.reg) as (LLVReg), to: CodeSlot.self) }
            emitSlot { $0.rawGlobal }
        }
    }

    struct CallOperand: Equatable, InstructionImmediate {
        var rawCallee: UInt64
        var spAddend: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (rawCallee) = pc.read((UInt64).self)
            let (spAddend, _, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(rawCallee: rawCallee, spAddend: spAddend)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { $0.rawCallee }
            emitSlot { unsafeBitCast(($0.spAddend, 0, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct CallIndirectOperand: Equatable, InstructionImmediate {
        var tableIndex: UInt32
        var rawType: UInt32
        var index: VReg
        var spAddend: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (tableIndex, rawType) = pc.read((UInt32, UInt32).self)
            let (index, spAddend, _, _, _, _) = pc.read((VReg, VReg, UInt8, UInt8, UInt8, UInt8).self)
            return Self(tableIndex: tableIndex, rawType: rawType, index: index, spAddend: spAddend)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.tableIndex, $0.rawType) as (UInt32, UInt32), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.index, $0.spAddend, 0, 0, 0, 0) as (VReg, VReg, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct ResizeFrameHeaderOperand: Equatable, InstructionImmediate {
        var delta: VReg
        var sizeToCopy: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (delta, sizeToCopy, _, _, _, _) = pc.read((VReg, VReg, UInt8, UInt8, UInt8, UInt8).self)
            return Self(delta: delta, sizeToCopy: sizeToCopy)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.delta, $0.sizeToCopy, 0, 0, 0, 0) as (VReg, VReg, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct ReturnCallOperand: Equatable, InstructionImmediate {
        var rawCallee: UInt64
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (rawCallee) = pc.read((UInt64).self)
            return Self(rawCallee: rawCallee)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { $0.rawCallee }
        }
    }

    struct ReturnCallIndirectOperand: Equatable, InstructionImmediate {
        var tableIndex: UInt32
        var rawType: UInt32
        var index: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (tableIndex, rawType) = pc.read((UInt32, UInt32).self)
            let (index, _, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(tableIndex: tableIndex, rawType: rawType, index: index)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.tableIndex, $0.rawType) as (UInt32, UInt32), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.index, 0, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct BrIfOperand: Equatable, InstructionImmediate {
        var condition: LVReg
        var offset: Int32
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (condition, offset) = pc.read((LVReg, Int32).self)
            return Self(condition: condition, offset: offset)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.condition, $0.offset) as (LVReg, Int32), to: CodeSlot.self) }
        }
    }

    struct BrTableOperand: Equatable, InstructionImmediate {
        var rawBaseAddress: UInt64
        var count: UInt16
        var index: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (rawBaseAddress) = pc.read((UInt64).self)
            let (count, index, _, _, _, _) = pc.read((UInt16, VReg, UInt8, UInt8, UInt8, UInt8).self)
            return Self(rawBaseAddress: rawBaseAddress, count: count, index: index)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { $0.rawBaseAddress }
            emitSlot { unsafeBitCast(($0.count, $0.index, 0, 0, 0, 0) as (UInt16, VReg, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct LoadOperand: Equatable, InstructionImmediate {
        var offset: UInt64
        var pointer: VReg
        var result: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (offset) = pc.read((UInt64).self)
            let (pointer, result, _, _, _, _) = pc.read((VReg, VReg, UInt8, UInt8, UInt8, UInt8).self)
            return Self(offset: offset, pointer: pointer, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { $0.offset }
            emitSlot { unsafeBitCast(($0.pointer, $0.result, 0, 0, 0, 0) as (VReg, VReg, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct StoreOperand: Equatable, InstructionImmediate {
        var offset: UInt64
        var pointer: VReg
        var value: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (offset) = pc.read((UInt64).self)
            let (pointer, value, _, _, _, _) = pc.read((VReg, VReg, UInt8, UInt8, UInt8, UInt8).self)
            return Self(offset: offset, pointer: pointer, value: value)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { $0.offset }
            emitSlot { unsafeBitCast(($0.pointer, $0.value, 0, 0, 0, 0) as (VReg, VReg, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct MemorySizeOperand: Equatable, InstructionImmediate {
        var memoryIndex: UInt32
        var result: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (memoryIndex, result) = pc.read((UInt32, LVReg).self)
            return Self(memoryIndex: memoryIndex, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.memoryIndex, $0.result) as (UInt32, LVReg), to: CodeSlot.self) }
        }
    }

    struct MemoryGrowOperand: Equatable, InstructionImmediate {
        var result: VReg
        var delta: VReg
        var memory: UInt32
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (result, delta, memory) = pc.read((VReg, VReg, UInt32).self)
            return Self(result: result, delta: delta, memory: memory)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.result, $0.delta, $0.memory) as (VReg, VReg, UInt32), to: CodeSlot.self) }
        }
    }

    struct MemoryInitOperand: Equatable, InstructionImmediate {
        var segmentIndex: UInt32
        var destOffset: VReg
        var sourceOffset: VReg
        var size: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (segmentIndex, destOffset, sourceOffset) = pc.read((UInt32, VReg, VReg).self)
            let (size, _, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(segmentIndex: segmentIndex, destOffset: destOffset, sourceOffset: sourceOffset, size: size)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.segmentIndex, $0.destOffset, $0.sourceOffset) as (UInt32, VReg, VReg), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.size, 0, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct MemoryDataDropOperand: Equatable, InstructionImmediate {
        var segmentIndex: UInt32
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (segmentIndex, _, _, _, _) = pc.read((UInt32, UInt8, UInt8, UInt8, UInt8).self)
            return Self(segmentIndex: segmentIndex)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.segmentIndex, 0, 0, 0, 0) as (UInt32, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct MemoryCopyOperand: Equatable, InstructionImmediate {
        var destOffset: VReg
        var sourceOffset: VReg
        var size: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (destOffset, sourceOffset, size) = pc.read((VReg, VReg, LVReg).self)
            return Self(destOffset: destOffset, sourceOffset: sourceOffset, size: size)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.destOffset, $0.sourceOffset, $0.size) as (VReg, VReg, LVReg), to: CodeSlot.self) }
        }
    }

    struct MemoryFillOperand: Equatable, InstructionImmediate {
        var destOffset: VReg
        var value: VReg
        var size: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (destOffset, value, size) = pc.read((VReg, VReg, LVReg).self)
            return Self(destOffset: destOffset, value: value, size: size)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.destOffset, $0.value, $0.size) as (VReg, VReg, LVReg), to: CodeSlot.self) }
        }
    }

    struct V128ConstOperand: Equatable, InstructionImmediate {
        var lo: UInt64
        var hi: UInt64
        var result: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (lo) = pc.read((UInt64).self)
            let (hi) = pc.read((UInt64).self)
            let (result, _, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(lo: lo, hi: hi, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { $0.lo }
            emitSlot { $0.hi }
            emitSlot { unsafeBitCast(($0.result, 0, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct I8x16ShuffleOperand: Equatable, InstructionImmediate {
        var lane0: UInt8
        var lane1: UInt8
        var lane2: UInt8
        var lane3: UInt8
        var lane4: UInt8
        var lane5: UInt8
        var lane6: UInt8
        var lane7: UInt8
        var lane8: UInt8
        var lane9: UInt8
        var lane10: UInt8
        var lane11: UInt8
        var lane12: UInt8
        var lane13: UInt8
        var lane14: UInt8
        var lane15: UInt8
        var lhs: VReg
        var rhs: VReg
        var result: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (lane0, lane1, lane2, lane3, lane4, lane5, lane6, lane7) = pc.read((UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            let (lane8, lane9, lane10, lane11, lane12, lane13, lane14, lane15) = pc.read((UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            let (lhs, rhs, result, _, _) = pc.read((VReg, VReg, VReg, UInt8, UInt8).self)
            return Self(lane0: lane0, lane1: lane1, lane2: lane2, lane3: lane3, lane4: lane4, lane5: lane5, lane6: lane6, lane7: lane7, lane8: lane8, lane9: lane9, lane10: lane10, lane11: lane11, lane12: lane12, lane13: lane13, lane14: lane14, lane15: lane15, lhs: lhs, rhs: rhs, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.lane0, $0.lane1, $0.lane2, $0.lane3, $0.lane4, $0.lane5, $0.lane6, $0.lane7) as (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.lane8, $0.lane9, $0.lane10, $0.lane11, $0.lane12, $0.lane13, $0.lane14, $0.lane15) as (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.lhs, $0.rhs, $0.result, 0, 0) as (VReg, VReg, VReg, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct SimdOperand: Equatable, InstructionImmediate {
        var opcode: UInt16
        var lane: UInt8
        var reserved: UInt8
        var offset: UInt64
        var input0: VReg
        var input1: VReg
        var input2: VReg
        var result: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (opcode, lane, reserved, _, _, _, _) = pc.read((UInt16, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            let (offset) = pc.read((UInt64).self)
            let (input0, input1, input2, result) = pc.read((VReg, VReg, VReg, VReg).self)
            return Self(opcode: opcode, lane: lane, reserved: reserved, offset: offset, input0: input0, input1: input1, input2: input2, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.opcode, $0.lane, $0.reserved, 0, 0, 0, 0) as (UInt16, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
            emitSlot { $0.offset }
            emitSlot { unsafeBitCast(($0.input0, $0.input1, $0.input2, $0.result) as (VReg, VReg, VReg, VReg), to: CodeSlot.self) }
        }
    }

    struct Const32Operand: Equatable, InstructionImmediate {
        var value: UInt32
        var result: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (value, result) = pc.read((UInt32, LVReg).self)
            return Self(value: value, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.value, $0.result) as (UInt32, LVReg), to: CodeSlot.self) }
        }
    }

    struct Const64Operand: Equatable, InstructionImmediate {
        var value: UntypedValue
        var result: LLVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (value) = pc.read((UntypedValue).self)
            let (result) = pc.read((LLVReg).self)
            return Self(value: value, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.value) as (UntypedValue), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.result) as (LLVReg), to: CodeSlot.self) }
        }
    }

    struct BinaryOperand: Equatable, InstructionImmediate {
        var result: LVReg
        var lhs: VReg
        var rhs: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (result, lhs, rhs) = pc.read((LVReg, VReg, VReg).self)
            return Self(result: result, lhs: lhs, rhs: rhs)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.result, $0.lhs, $0.rhs) as (LVReg, VReg, VReg), to: CodeSlot.self) }
        }
    }

    struct UnaryOperand: Equatable, InstructionImmediate {
        var result: LVReg
        var input: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (result, input) = pc.read((LVReg, LVReg).self)
            return Self(result: result, input: input)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.result, $0.input) as (LVReg, LVReg), to: CodeSlot.self) }
        }
    }

    struct SelectOperand: Equatable, InstructionImmediate {
        var result: VReg
        var condition: VReg
        var onTrue: VReg
        var onFalse: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (result, condition, onTrue, onFalse) = pc.read((VReg, VReg, VReg, VReg).self)
            return Self(result: result, condition: condition, onTrue: onTrue, onFalse: onFalse)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.result, $0.condition, $0.onTrue, $0.onFalse) as (VReg, VReg, VReg, VReg), to: CodeSlot.self) }
        }
    }

    struct RefNullOperand: Equatable, InstructionImmediate {
        var result: VReg
        var rawType: UInt8
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (result, rawType, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(result: result, rawType: rawType)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.result, $0.rawType, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct RefIsNullOperand: Equatable, InstructionImmediate {
        var value: LVReg
        var result: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (value, result) = pc.read((LVReg, LVReg).self)
            return Self(value: value, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.value, $0.result) as (LVReg, LVReg), to: CodeSlot.self) }
        }
    }

    struct RefFuncOperand: Equatable, InstructionImmediate {
        var index: UInt32
        var result: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (index, result) = pc.read((UInt32, LVReg).self)
            return Self(index: index, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.index, $0.result) as (UInt32, LVReg), to: CodeSlot.self) }
        }
    }

    struct TableGetOperand: Equatable, InstructionImmediate {
        var index: VReg
        var result: VReg
        var tableIndex: UInt32
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (index, result, tableIndex) = pc.read((VReg, VReg, UInt32).self)
            return Self(index: index, result: result, tableIndex: tableIndex)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.index, $0.result, $0.tableIndex) as (VReg, VReg, UInt32), to: CodeSlot.self) }
        }
    }

    struct TableSetOperand: Equatable, InstructionImmediate {
        var index: VReg
        var value: VReg
        var tableIndex: UInt32
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (index, value, tableIndex) = pc.read((VReg, VReg, UInt32).self)
            return Self(index: index, value: value, tableIndex: tableIndex)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.index, $0.value, $0.tableIndex) as (VReg, VReg, UInt32), to: CodeSlot.self) }
        }
    }

    struct TableSizeOperand: Equatable, InstructionImmediate {
        var tableIndex: UInt32
        var result: LVReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (tableIndex, result) = pc.read((UInt32, LVReg).self)
            return Self(tableIndex: tableIndex, result: result)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.tableIndex, $0.result) as (UInt32, LVReg), to: CodeSlot.self) }
        }
    }

    struct TableGrowOperand: Equatable, InstructionImmediate {
        var tableIndex: UInt32
        var result: VReg
        var delta: VReg
        var value: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (tableIndex, result, delta) = pc.read((UInt32, VReg, VReg).self)
            let (value, _, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(tableIndex: tableIndex, result: result, delta: delta, value: value)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.tableIndex, $0.result, $0.delta) as (UInt32, VReg, VReg), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.value, 0, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct TableFillOperand: Equatable, InstructionImmediate {
        var tableIndex: UInt32
        var destOffset: VReg
        var value: VReg
        var size: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (tableIndex, destOffset, value) = pc.read((UInt32, VReg, VReg).self)
            let (size, _, _, _, _, _, _) = pc.read((VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).self)
            return Self(tableIndex: tableIndex, destOffset: destOffset, value: value, size: size)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.tableIndex, $0.destOffset, $0.value) as (UInt32, VReg, VReg), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.size, 0, 0, 0, 0, 0, 0) as (VReg, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct TableCopyOperand: Equatable, InstructionImmediate {
        var sourceIndex: UInt32
        var destIndex: UInt32
        var destOffset: VReg
        var sourceOffset: VReg
        var size: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (sourceIndex, destIndex) = pc.read((UInt32, UInt32).self)
            let (destOffset, sourceOffset, size, _, _) = pc.read((VReg, VReg, VReg, UInt8, UInt8).self)
            return Self(sourceIndex: sourceIndex, destIndex: destIndex, destOffset: destOffset, sourceOffset: sourceOffset, size: size)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.sourceIndex, $0.destIndex) as (UInt32, UInt32), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.destOffset, $0.sourceOffset, $0.size, 0, 0) as (VReg, VReg, VReg, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct TableInitOperand: Equatable, InstructionImmediate {
        var tableIndex: UInt32
        var segmentIndex: UInt32
        var destOffset: VReg
        var sourceOffset: VReg
        var size: VReg
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (tableIndex, segmentIndex) = pc.read((UInt32, UInt32).self)
            let (destOffset, sourceOffset, size, _, _) = pc.read((VReg, VReg, VReg, UInt8, UInt8).self)
            return Self(tableIndex: tableIndex, segmentIndex: segmentIndex, destOffset: destOffset, sourceOffset: sourceOffset, size: size)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.tableIndex, $0.segmentIndex) as (UInt32, UInt32), to: CodeSlot.self) }
            emitSlot { unsafeBitCast(($0.destOffset, $0.sourceOffset, $0.size, 0, 0) as (VReg, VReg, VReg, UInt8, UInt8), to: CodeSlot.self) }
        }
    }

    struct TableElementDropOperand: Equatable, InstructionImmediate {
        var index: UInt32
        @inline(__always) static func load(from pc: inout Pc) -> Self {
            let (index, _, _, _, _) = pc.read((UInt32, UInt8, UInt8, UInt8, UInt8).self)
            return Self(index: index)
        }
        @inline(__always) static func emit(to emitSlot: ((Self) -> CodeSlot) -> Void) {
            emitSlot { unsafeBitCast(($0.index, 0, 0, 0, 0) as (UInt32, UInt8, UInt8, UInt8, UInt8), to: CodeSlot.self) }
        }
    }
}

extension Instruction {
    var rawImmediate: (any InstructionImmediate)? {
        switch self {
        case .copyStack(let immediate): return immediate
        case .globalGet(let immediate): return immediate
        case .globalSet(let immediate): return immediate
        case .call(let immediate): return immediate
        case .compilingCall(let immediate): return immediate
        case .internalCall(let immediate): return immediate
        case .callIndirect(let immediate): return immediate
        case .resizeFrameHeader(let immediate): return immediate
        case .returnCall(let immediate): return immediate
        case .returnCallIndirect(let immediate): return immediate
        case .br(let immediate): return immediate
        case .brIf(let immediate): return immediate
        case .brIfNot(let immediate): return immediate
        case .brTable(let immediate): return immediate
        case .i32Load(let immediate): return immediate
        case .i64Load(let immediate): return immediate
        case .f32Load(let immediate): return immediate
        case .f64Load(let immediate): return immediate
        case .i32Load8S(let immediate): return immediate
        case .i32Load8U(let immediate): return immediate
        case .i32Load16S(let immediate): return immediate
        case .i32Load16U(let immediate): return immediate
        case .i64Load8S(let immediate): return immediate
        case .i64Load8U(let immediate): return immediate
        case .i64Load16S(let immediate): return immediate
        case .i64Load16U(let immediate): return immediate
        case .i64Load32S(let immediate): return immediate
        case .i64Load32U(let immediate): return immediate
        case .i32Store(let immediate): return immediate
        case .i64Store(let immediate): return immediate
        case .f32Store(let immediate): return immediate
        case .f64Store(let immediate): return immediate
        case .i32Store8(let immediate): return immediate
        case .i32Store16(let immediate): return immediate
        case .i64Store8(let immediate): return immediate
        case .i64Store16(let immediate): return immediate
        case .i64Store32(let immediate): return immediate
        case .memorySize(let immediate): return immediate
        case .memoryGrow(let immediate): return immediate
        case .memoryInit(let immediate): return immediate
        case .memoryDataDrop(let immediate): return immediate
        case .memoryCopy(let immediate): return immediate
        case .memoryFill(let immediate): return immediate
        case .v128Const(let immediate): return immediate
        case .i8x16Shuffle(let immediate): return immediate
        case .simd(let immediate): return immediate
        case .const32(let immediate): return immediate
        case .const64(let immediate): return immediate
        case .i32Add(let immediate): return immediate
        case .i64Add(let immediate): return immediate
        case .i32Sub(let immediate): return immediate
        case .i64Sub(let immediate): return immediate
        case .i32Mul(let immediate): return immediate
        case .i64Mul(let immediate): return immediate
        case .i32And(let immediate): return immediate
        case .i64And(let immediate): return immediate
        case .i32Or(let immediate): return immediate
        case .i64Or(let immediate): return immediate
        case .i32Xor(let immediate): return immediate
        case .i64Xor(let immediate): return immediate
        case .i32Shl(let immediate): return immediate
        case .i64Shl(let immediate): return immediate
        case .i32ShrS(let immediate): return immediate
        case .i64ShrS(let immediate): return immediate
        case .i32ShrU(let immediate): return immediate
        case .i64ShrU(let immediate): return immediate
        case .i32Rotl(let immediate): return immediate
        case .i64Rotl(let immediate): return immediate
        case .i32Rotr(let immediate): return immediate
        case .i64Rotr(let immediate): return immediate
        case .i32DivS(let immediate): return immediate
        case .i64DivS(let immediate): return immediate
        case .i32DivU(let immediate): return immediate
        case .i64DivU(let immediate): return immediate
        case .i32RemS(let immediate): return immediate
        case .i64RemS(let immediate): return immediate
        case .i32RemU(let immediate): return immediate
        case .i64RemU(let immediate): return immediate
        case .i32Eq(let immediate): return immediate
        case .i64Eq(let immediate): return immediate
        case .i32Ne(let immediate): return immediate
        case .i64Ne(let immediate): return immediate
        case .i32LtS(let immediate): return immediate
        case .i64LtS(let immediate): return immediate
        case .i32LtU(let immediate): return immediate
        case .i64LtU(let immediate): return immediate
        case .i32GtS(let immediate): return immediate
        case .i64GtS(let immediate): return immediate
        case .i32GtU(let immediate): return immediate
        case .i64GtU(let immediate): return immediate
        case .i32LeS(let immediate): return immediate
        case .i64LeS(let immediate): return immediate
        case .i32LeU(let immediate): return immediate
        case .i64LeU(let immediate): return immediate
        case .i32GeS(let immediate): return immediate
        case .i64GeS(let immediate): return immediate
        case .i32GeU(let immediate): return immediate
        case .i64GeU(let immediate): return immediate
        case .i32Clz(let immediate): return immediate
        case .i64Clz(let immediate): return immediate
        case .i32Ctz(let immediate): return immediate
        case .i64Ctz(let immediate): return immediate
        case .i32Popcnt(let immediate): return immediate
        case .i64Popcnt(let immediate): return immediate
        case .i32Eqz(let immediate): return immediate
        case .i64Eqz(let immediate): return immediate
        case .i32WrapI64(let immediate): return immediate
        case .i64ExtendI32S(let immediate): return immediate
        case .i64ExtendI32U(let immediate): return immediate
        case .i32Extend8S(let immediate): return immediate
        case .i64Extend8S(let immediate): return immediate
        case .i32Extend16S(let immediate): return immediate
        case .i64Extend16S(let immediate): return immediate
        case .i64Extend32S(let immediate): return immediate
        case .i32TruncF32S(let immediate): return immediate
        case .i32TruncF32U(let immediate): return immediate
        case .i32TruncSatF32S(let immediate): return immediate
        case .i32TruncSatF32U(let immediate): return immediate
        case .i32TruncF64S(let immediate): return immediate
        case .i32TruncF64U(let immediate): return immediate
        case .i32TruncSatF64S(let immediate): return immediate
        case .i32TruncSatF64U(let immediate): return immediate
        case .i64TruncF32S(let immediate): return immediate
        case .i64TruncF32U(let immediate): return immediate
        case .i64TruncSatF32S(let immediate): return immediate
        case .i64TruncSatF32U(let immediate): return immediate
        case .i64TruncF64S(let immediate): return immediate
        case .i64TruncF64U(let immediate): return immediate
        case .i64TruncSatF64S(let immediate): return immediate
        case .i64TruncSatF64U(let immediate): return immediate
        case .f32ConvertI32S(let immediate): return immediate
        case .f32ConvertI32U(let immediate): return immediate
        case .f32ConvertI64S(let immediate): return immediate
        case .f32ConvertI64U(let immediate): return immediate
        case .f64ConvertI32S(let immediate): return immediate
        case .f64ConvertI32U(let immediate): return immediate
        case .f64ConvertI64S(let immediate): return immediate
        case .f64ConvertI64U(let immediate): return immediate
        case .f32ReinterpretI32(let immediate): return immediate
        case .f64ReinterpretI64(let immediate): return immediate
        case .i32ReinterpretF32(let immediate): return immediate
        case .i64ReinterpretF64(let immediate): return immediate
        case .f32Add(let immediate): return immediate
        case .f64Add(let immediate): return immediate
        case .f32Sub(let immediate): return immediate
        case .f64Sub(let immediate): return immediate
        case .f32Mul(let immediate): return immediate
        case .f64Mul(let immediate): return immediate
        case .f32Div(let immediate): return immediate
        case .f64Div(let immediate): return immediate
        case .f32Min(let immediate): return immediate
        case .f64Min(let immediate): return immediate
        case .f32Max(let immediate): return immediate
        case .f64Max(let immediate): return immediate
        case .f32CopySign(let immediate): return immediate
        case .f64CopySign(let immediate): return immediate
        case .f32Eq(let immediate): return immediate
        case .f64Eq(let immediate): return immediate
        case .f32Ne(let immediate): return immediate
        case .f64Ne(let immediate): return immediate
        case .f32Lt(let immediate): return immediate
        case .f64Lt(let immediate): return immediate
        case .f32Gt(let immediate): return immediate
        case .f64Gt(let immediate): return immediate
        case .f32Le(let immediate): return immediate
        case .f64Le(let immediate): return immediate
        case .f32Ge(let immediate): return immediate
        case .f64Ge(let immediate): return immediate
        case .f32Abs(let immediate): return immediate
        case .f64Abs(let immediate): return immediate
        case .f32Neg(let immediate): return immediate
        case .f64Neg(let immediate): return immediate
        case .f32Ceil(let immediate): return immediate
        case .f64Ceil(let immediate): return immediate
        case .f32Floor(let immediate): return immediate
        case .f64Floor(let immediate): return immediate
        case .f32Trunc(let immediate): return immediate
        case .f64Trunc(let immediate): return immediate
        case .f32Nearest(let immediate): return immediate
        case .f64Nearest(let immediate): return immediate
        case .f32Sqrt(let immediate): return immediate
        case .f64Sqrt(let immediate): return immediate
        case .f64PromoteF32(let immediate): return immediate
        case .f32DemoteF64(let immediate): return immediate
        case .select(let immediate): return immediate
        case .refNull(let immediate): return immediate
        case .refIsNull(let immediate): return immediate
        case .refFunc(let immediate): return immediate
        case .tableGet(let immediate): return immediate
        case .tableSet(let immediate): return immediate
        case .tableSize(let immediate): return immediate
        case .tableGrow(let immediate): return immediate
        case .tableFill(let immediate): return immediate
        case .tableCopy(let immediate): return immediate
        case .tableInit(let immediate): return immediate
        case .tableElementDrop(let immediate): return immediate
        case .onEnter(let immediate): return immediate
        case .onExit(let immediate): return immediate
        case .i32AtomicLoad(let immediate): return immediate
        case .i64AtomicLoad(let immediate): return immediate
        case .i32AtomicLoad8U(let immediate): return immediate
        case .i32AtomicLoad16U(let immediate): return immediate
        case .i64AtomicLoad8U(let immediate): return immediate
        case .i64AtomicLoad16U(let immediate): return immediate
        case .i64AtomicLoad32U(let immediate): return immediate
        case .i32AtomicStore(let immediate): return immediate
        case .i64AtomicStore(let immediate): return immediate
        case .i32AtomicStore8(let immediate): return immediate
        case .i32AtomicStore16(let immediate): return immediate
        case .i64AtomicStore8(let immediate): return immediate
        case .i64AtomicStore16(let immediate): return immediate
        case .i64AtomicStore32(let immediate): return immediate
        default: return nil
        }
    }
}


extension Instruction {
    /// The opcode ID of the instruction.
    var opcodeID: OpcodeID {
        switch self {
        case .copyStack: return 0
        case .globalGet: return 1
        case .globalSet: return 2
        case .call: return 3
        case .compilingCall: return 4
        case .internalCall: return 5
        case .callIndirect: return 6
        case .resizeFrameHeader: return 7
        case .returnCall: return 8
        case .returnCallIndirect: return 9
        case .unreachable: return 10
        case .nop: return 11
        case .br: return 12
        case .brIf: return 13
        case .brIfNot: return 14
        case .brTable: return 15
        case ._return: return 16
        case .endOfExecution: return 17
        case .i32Load: return 18
        case .i64Load: return 19
        case .f32Load: return 20
        case .f64Load: return 21
        case .i32Load8S: return 22
        case .i32Load8U: return 23
        case .i32Load16S: return 24
        case .i32Load16U: return 25
        case .i64Load8S: return 26
        case .i64Load8U: return 27
        case .i64Load16S: return 28
        case .i64Load16U: return 29
        case .i64Load32S: return 30
        case .i64Load32U: return 31
        case .i32Store: return 32
        case .i64Store: return 33
        case .f32Store: return 34
        case .f64Store: return 35
        case .i32Store8: return 36
        case .i32Store16: return 37
        case .i64Store8: return 38
        case .i64Store16: return 39
        case .i64Store32: return 40
        case .memorySize: return 41
        case .memoryGrow: return 42
        case .memoryInit: return 43
        case .memoryDataDrop: return 44
        case .memoryCopy: return 45
        case .memoryFill: return 46
        case .v128Const: return 47
        case .i8x16Shuffle: return 48
        case .simd: return 49
        case .const32: return 50
        case .const64: return 51
        case .i32Add: return 52
        case .i64Add: return 53
        case .i32Sub: return 54
        case .i64Sub: return 55
        case .i32Mul: return 56
        case .i64Mul: return 57
        case .i32And: return 58
        case .i64And: return 59
        case .i32Or: return 60
        case .i64Or: return 61
        case .i32Xor: return 62
        case .i64Xor: return 63
        case .i32Shl: return 64
        case .i64Shl: return 65
        case .i32ShrS: return 66
        case .i64ShrS: return 67
        case .i32ShrU: return 68
        case .i64ShrU: return 69
        case .i32Rotl: return 70
        case .i64Rotl: return 71
        case .i32Rotr: return 72
        case .i64Rotr: return 73
        case .i32DivS: return 74
        case .i64DivS: return 75
        case .i32DivU: return 76
        case .i64DivU: return 77
        case .i32RemS: return 78
        case .i64RemS: return 79
        case .i32RemU: return 80
        case .i64RemU: return 81
        case .i32Eq: return 82
        case .i64Eq: return 83
        case .i32Ne: return 84
        case .i64Ne: return 85
        case .i32LtS: return 86
        case .i64LtS: return 87
        case .i32LtU: return 88
        case .i64LtU: return 89
        case .i32GtS: return 90
        case .i64GtS: return 91
        case .i32GtU: return 92
        case .i64GtU: return 93
        case .i32LeS: return 94
        case .i64LeS: return 95
        case .i32LeU: return 96
        case .i64LeU: return 97
        case .i32GeS: return 98
        case .i64GeS: return 99
        case .i32GeU: return 100
        case .i64GeU: return 101
        case .i32Clz: return 102
        case .i64Clz: return 103
        case .i32Ctz: return 104
        case .i64Ctz: return 105
        case .i32Popcnt: return 106
        case .i64Popcnt: return 107
        case .i32Eqz: return 108
        case .i64Eqz: return 109
        case .i32WrapI64: return 110
        case .i64ExtendI32S: return 111
        case .i64ExtendI32U: return 112
        case .i32Extend8S: return 113
        case .i64Extend8S: return 114
        case .i32Extend16S: return 115
        case .i64Extend16S: return 116
        case .i64Extend32S: return 117
        case .i32TruncF32S: return 118
        case .i32TruncF32U: return 119
        case .i32TruncSatF32S: return 120
        case .i32TruncSatF32U: return 121
        case .i32TruncF64S: return 122
        case .i32TruncF64U: return 123
        case .i32TruncSatF64S: return 124
        case .i32TruncSatF64U: return 125
        case .i64TruncF32S: return 126
        case .i64TruncF32U: return 127
        case .i64TruncSatF32S: return 128
        case .i64TruncSatF32U: return 129
        case .i64TruncF64S: return 130
        case .i64TruncF64U: return 131
        case .i64TruncSatF64S: return 132
        case .i64TruncSatF64U: return 133
        case .f32ConvertI32S: return 134
        case .f32ConvertI32U: return 135
        case .f32ConvertI64S: return 136
        case .f32ConvertI64U: return 137
        case .f64ConvertI32S: return 138
        case .f64ConvertI32U: return 139
        case .f64ConvertI64S: return 140
        case .f64ConvertI64U: return 141
        case .f32ReinterpretI32: return 142
        case .f64ReinterpretI64: return 143
        case .i32ReinterpretF32: return 144
        case .i64ReinterpretF64: return 145
        case .f32Add: return 146
        case .f64Add: return 147
        case .f32Sub: return 148
        case .f64Sub: return 149
        case .f32Mul: return 150
        case .f64Mul: return 151
        case .f32Div: return 152
        case .f64Div: return 153
        case .f32Min: return 154
        case .f64Min: return 155
        case .f32Max: return 156
        case .f64Max: return 157
        case .f32CopySign: return 158
        case .f64CopySign: return 159
        case .f32Eq: return 160
        case .f64Eq: return 161
        case .f32Ne: return 162
        case .f64Ne: return 163
        case .f32Lt: return 164
        case .f64Lt: return 165
        case .f32Gt: return 166
        case .f64Gt: return 167
        case .f32Le: return 168
        case .f64Le: return 169
        case .f32Ge: return 170
        case .f64Ge: return 171
        case .f32Abs: return 172
        case .f64Abs: return 173
        case .f32Neg: return 174
        case .f64Neg: return 175
        case .f32Ceil: return 176
        case .f64Ceil: return 177
        case .f32Floor: return 178
        case .f64Floor: return 179
        case .f32Trunc: return 180
        case .f64Trunc: return 181
        case .f32Nearest: return 182
        case .f64Nearest: return 183
        case .f32Sqrt: return 184
        case .f64Sqrt: return 185
        case .f64PromoteF32: return 186
        case .f32DemoteF64: return 187
        case .select: return 188
        case .refNull: return 189
        case .refIsNull: return 190
        case .refFunc: return 191
        case .tableGet: return 192
        case .tableSet: return 193
        case .tableSize: return 194
        case .tableGrow: return 195
        case .tableFill: return 196
        case .tableCopy: return 197
        case .tableInit: return 198
        case .tableElementDrop: return 199
        case .onEnter: return 200
        case .onExit: return 201
        case .breakpoint: return 202
        case .i32AtomicLoad: return 203
        case .i64AtomicLoad: return 204
        case .i32AtomicLoad8U: return 205
        case .i32AtomicLoad16U: return 206
        case .i64AtomicLoad8U: return 207
        case .i64AtomicLoad16U: return 208
        case .i64AtomicLoad32U: return 209
        case .i32AtomicStore: return 210
        case .i64AtomicStore: return 211
        case .i32AtomicStore8: return 212
        case .i32AtomicStore16: return 213
        case .i64AtomicStore8: return 214
        case .i64AtomicStore16: return 215
        case .i64AtomicStore32: return 216
        }
    }
}
extension Instruction {
    /// Load an instruction from the given program counter.
    /// - Parameter pc: The program counter to read from.
    /// - Returns: The instruction read from the program counter.
    /// - Precondition: The instruction sequence must be compiled with token threading model.
    static func load(from pc: inout Pc) -> Instruction {
        let opcode = pc.read(UInt64.self)
        switch opcode {
        case 0: return .copyStack(Instruction.CopyStackOperand.load(from: &pc))
        case 1: return .globalGet(Instruction.GlobalAndVRegOperand.load(from: &pc))
        case 2: return .globalSet(Instruction.GlobalAndVRegOperand.load(from: &pc))
        case 3: return .call(Instruction.CallOperand.load(from: &pc))
        case 4: return .compilingCall(Instruction.CallOperand.load(from: &pc))
        case 5: return .internalCall(Instruction.CallOperand.load(from: &pc))
        case 6: return .callIndirect(Instruction.CallIndirectOperand.load(from: &pc))
        case 7: return .resizeFrameHeader(Instruction.ResizeFrameHeaderOperand.load(from: &pc))
        case 8: return .returnCall(Instruction.ReturnCallOperand.load(from: &pc))
        case 9: return .returnCallIndirect(Instruction.ReturnCallIndirectOperand.load(from: &pc))
        case 10: return .unreachable
        case 11: return .nop
        case 12: return .br(Instruction.BrOperand.load(from: &pc))
        case 13: return .brIf(Instruction.BrIfOperand.load(from: &pc))
        case 14: return .brIfNot(Instruction.BrIfOperand.load(from: &pc))
        case 15: return .brTable(Instruction.BrTableOperand.load(from: &pc))
        case 16: return ._return
        case 17: return .endOfExecution
        case 18: return .i32Load(Instruction.LoadOperand.load(from: &pc))
        case 19: return .i64Load(Instruction.LoadOperand.load(from: &pc))
        case 20: return .f32Load(Instruction.LoadOperand.load(from: &pc))
        case 21: return .f64Load(Instruction.LoadOperand.load(from: &pc))
        case 22: return .i32Load8S(Instruction.LoadOperand.load(from: &pc))
        case 23: return .i32Load8U(Instruction.LoadOperand.load(from: &pc))
        case 24: return .i32Load16S(Instruction.LoadOperand.load(from: &pc))
        case 25: return .i32Load16U(Instruction.LoadOperand.load(from: &pc))
        case 26: return .i64Load8S(Instruction.LoadOperand.load(from: &pc))
        case 27: return .i64Load8U(Instruction.LoadOperand.load(from: &pc))
        case 28: return .i64Load16S(Instruction.LoadOperand.load(from: &pc))
        case 29: return .i64Load16U(Instruction.LoadOperand.load(from: &pc))
        case 30: return .i64Load32S(Instruction.LoadOperand.load(from: &pc))
        case 31: return .i64Load32U(Instruction.LoadOperand.load(from: &pc))
        case 32: return .i32Store(Instruction.StoreOperand.load(from: &pc))
        case 33: return .i64Store(Instruction.StoreOperand.load(from: &pc))
        case 34: return .f32Store(Instruction.StoreOperand.load(from: &pc))
        case 35: return .f64Store(Instruction.StoreOperand.load(from: &pc))
        case 36: return .i32Store8(Instruction.StoreOperand.load(from: &pc))
        case 37: return .i32Store16(Instruction.StoreOperand.load(from: &pc))
        case 38: return .i64Store8(Instruction.StoreOperand.load(from: &pc))
        case 39: return .i64Store16(Instruction.StoreOperand.load(from: &pc))
        case 40: return .i64Store32(Instruction.StoreOperand.load(from: &pc))
        case 41: return .memorySize(Instruction.MemorySizeOperand.load(from: &pc))
        case 42: return .memoryGrow(Instruction.MemoryGrowOperand.load(from: &pc))
        case 43: return .memoryInit(Instruction.MemoryInitOperand.load(from: &pc))
        case 44: return .memoryDataDrop(Instruction.MemoryDataDropOperand.load(from: &pc))
        case 45: return .memoryCopy(Instruction.MemoryCopyOperand.load(from: &pc))
        case 46: return .memoryFill(Instruction.MemoryFillOperand.load(from: &pc))
        case 47: return .v128Const(Instruction.V128ConstOperand.load(from: &pc))
        case 48: return .i8x16Shuffle(Instruction.I8x16ShuffleOperand.load(from: &pc))
        case 49: return .simd(Instruction.SimdOperand.load(from: &pc))
        case 50: return .const32(Instruction.Const32Operand.load(from: &pc))
        case 51: return .const64(Instruction.Const64Operand.load(from: &pc))
        case 52: return .i32Add(Instruction.BinaryOperand.load(from: &pc))
        case 53: return .i64Add(Instruction.BinaryOperand.load(from: &pc))
        case 54: return .i32Sub(Instruction.BinaryOperand.load(from: &pc))
        case 55: return .i64Sub(Instruction.BinaryOperand.load(from: &pc))
        case 56: return .i32Mul(Instruction.BinaryOperand.load(from: &pc))
        case 57: return .i64Mul(Instruction.BinaryOperand.load(from: &pc))
        case 58: return .i32And(Instruction.BinaryOperand.load(from: &pc))
        case 59: return .i64And(Instruction.BinaryOperand.load(from: &pc))
        case 60: return .i32Or(Instruction.BinaryOperand.load(from: &pc))
        case 61: return .i64Or(Instruction.BinaryOperand.load(from: &pc))
        case 62: return .i32Xor(Instruction.BinaryOperand.load(from: &pc))
        case 63: return .i64Xor(Instruction.BinaryOperand.load(from: &pc))
        case 64: return .i32Shl(Instruction.BinaryOperand.load(from: &pc))
        case 65: return .i64Shl(Instruction.BinaryOperand.load(from: &pc))
        case 66: return .i32ShrS(Instruction.BinaryOperand.load(from: &pc))
        case 67: return .i64ShrS(Instruction.BinaryOperand.load(from: &pc))
        case 68: return .i32ShrU(Instruction.BinaryOperand.load(from: &pc))
        case 69: return .i64ShrU(Instruction.BinaryOperand.load(from: &pc))
        case 70: return .i32Rotl(Instruction.BinaryOperand.load(from: &pc))
        case 71: return .i64Rotl(Instruction.BinaryOperand.load(from: &pc))
        case 72: return .i32Rotr(Instruction.BinaryOperand.load(from: &pc))
        case 73: return .i64Rotr(Instruction.BinaryOperand.load(from: &pc))
        case 74: return .i32DivS(Instruction.BinaryOperand.load(from: &pc))
        case 75: return .i64DivS(Instruction.BinaryOperand.load(from: &pc))
        case 76: return .i32DivU(Instruction.BinaryOperand.load(from: &pc))
        case 77: return .i64DivU(Instruction.BinaryOperand.load(from: &pc))
        case 78: return .i32RemS(Instruction.BinaryOperand.load(from: &pc))
        case 79: return .i64RemS(Instruction.BinaryOperand.load(from: &pc))
        case 80: return .i32RemU(Instruction.BinaryOperand.load(from: &pc))
        case 81: return .i64RemU(Instruction.BinaryOperand.load(from: &pc))
        case 82: return .i32Eq(Instruction.BinaryOperand.load(from: &pc))
        case 83: return .i64Eq(Instruction.BinaryOperand.load(from: &pc))
        case 84: return .i32Ne(Instruction.BinaryOperand.load(from: &pc))
        case 85: return .i64Ne(Instruction.BinaryOperand.load(from: &pc))
        case 86: return .i32LtS(Instruction.BinaryOperand.load(from: &pc))
        case 87: return .i64LtS(Instruction.BinaryOperand.load(from: &pc))
        case 88: return .i32LtU(Instruction.BinaryOperand.load(from: &pc))
        case 89: return .i64LtU(Instruction.BinaryOperand.load(from: &pc))
        case 90: return .i32GtS(Instruction.BinaryOperand.load(from: &pc))
        case 91: return .i64GtS(Instruction.BinaryOperand.load(from: &pc))
        case 92: return .i32GtU(Instruction.BinaryOperand.load(from: &pc))
        case 93: return .i64GtU(Instruction.BinaryOperand.load(from: &pc))
        case 94: return .i32LeS(Instruction.BinaryOperand.load(from: &pc))
        case 95: return .i64LeS(Instruction.BinaryOperand.load(from: &pc))
        case 96: return .i32LeU(Instruction.BinaryOperand.load(from: &pc))
        case 97: return .i64LeU(Instruction.BinaryOperand.load(from: &pc))
        case 98: return .i32GeS(Instruction.BinaryOperand.load(from: &pc))
        case 99: return .i64GeS(Instruction.BinaryOperand.load(from: &pc))
        case 100: return .i32GeU(Instruction.BinaryOperand.load(from: &pc))
        case 101: return .i64GeU(Instruction.BinaryOperand.load(from: &pc))
        case 102: return .i32Clz(Instruction.UnaryOperand.load(from: &pc))
        case 103: return .i64Clz(Instruction.UnaryOperand.load(from: &pc))
        case 104: return .i32Ctz(Instruction.UnaryOperand.load(from: &pc))
        case 105: return .i64Ctz(Instruction.UnaryOperand.load(from: &pc))
        case 106: return .i32Popcnt(Instruction.UnaryOperand.load(from: &pc))
        case 107: return .i64Popcnt(Instruction.UnaryOperand.load(from: &pc))
        case 108: return .i32Eqz(Instruction.UnaryOperand.load(from: &pc))
        case 109: return .i64Eqz(Instruction.UnaryOperand.load(from: &pc))
        case 110: return .i32WrapI64(Instruction.UnaryOperand.load(from: &pc))
        case 111: return .i64ExtendI32S(Instruction.UnaryOperand.load(from: &pc))
        case 112: return .i64ExtendI32U(Instruction.UnaryOperand.load(from: &pc))
        case 113: return .i32Extend8S(Instruction.UnaryOperand.load(from: &pc))
        case 114: return .i64Extend8S(Instruction.UnaryOperand.load(from: &pc))
        case 115: return .i32Extend16S(Instruction.UnaryOperand.load(from: &pc))
        case 116: return .i64Extend16S(Instruction.UnaryOperand.load(from: &pc))
        case 117: return .i64Extend32S(Instruction.UnaryOperand.load(from: &pc))
        case 118: return .i32TruncF32S(Instruction.UnaryOperand.load(from: &pc))
        case 119: return .i32TruncF32U(Instruction.UnaryOperand.load(from: &pc))
        case 120: return .i32TruncSatF32S(Instruction.UnaryOperand.load(from: &pc))
        case 121: return .i32TruncSatF32U(Instruction.UnaryOperand.load(from: &pc))
        case 122: return .i32TruncF64S(Instruction.UnaryOperand.load(from: &pc))
        case 123: return .i32TruncF64U(Instruction.UnaryOperand.load(from: &pc))
        case 124: return .i32TruncSatF64S(Instruction.UnaryOperand.load(from: &pc))
        case 125: return .i32TruncSatF64U(Instruction.UnaryOperand.load(from: &pc))
        case 126: return .i64TruncF32S(Instruction.UnaryOperand.load(from: &pc))
        case 127: return .i64TruncF32U(Instruction.UnaryOperand.load(from: &pc))
        case 128: return .i64TruncSatF32S(Instruction.UnaryOperand.load(from: &pc))
        case 129: return .i64TruncSatF32U(Instruction.UnaryOperand.load(from: &pc))
        case 130: return .i64TruncF64S(Instruction.UnaryOperand.load(from: &pc))
        case 131: return .i64TruncF64U(Instruction.UnaryOperand.load(from: &pc))
        case 132: return .i64TruncSatF64S(Instruction.UnaryOperand.load(from: &pc))
        case 133: return .i64TruncSatF64U(Instruction.UnaryOperand.load(from: &pc))
        case 134: return .f32ConvertI32S(Instruction.UnaryOperand.load(from: &pc))
        case 135: return .f32ConvertI32U(Instruction.UnaryOperand.load(from: &pc))
        case 136: return .f32ConvertI64S(Instruction.UnaryOperand.load(from: &pc))
        case 137: return .f32ConvertI64U(Instruction.UnaryOperand.load(from: &pc))
        case 138: return .f64ConvertI32S(Instruction.UnaryOperand.load(from: &pc))
        case 139: return .f64ConvertI32U(Instruction.UnaryOperand.load(from: &pc))
        case 140: return .f64ConvertI64S(Instruction.UnaryOperand.load(from: &pc))
        case 141: return .f64ConvertI64U(Instruction.UnaryOperand.load(from: &pc))
        case 142: return .f32ReinterpretI32(Instruction.UnaryOperand.load(from: &pc))
        case 143: return .f64ReinterpretI64(Instruction.UnaryOperand.load(from: &pc))
        case 144: return .i32ReinterpretF32(Instruction.UnaryOperand.load(from: &pc))
        case 145: return .i64ReinterpretF64(Instruction.UnaryOperand.load(from: &pc))
        case 146: return .f32Add(Instruction.BinaryOperand.load(from: &pc))
        case 147: return .f64Add(Instruction.BinaryOperand.load(from: &pc))
        case 148: return .f32Sub(Instruction.BinaryOperand.load(from: &pc))
        case 149: return .f64Sub(Instruction.BinaryOperand.load(from: &pc))
        case 150: return .f32Mul(Instruction.BinaryOperand.load(from: &pc))
        case 151: return .f64Mul(Instruction.BinaryOperand.load(from: &pc))
        case 152: return .f32Div(Instruction.BinaryOperand.load(from: &pc))
        case 153: return .f64Div(Instruction.BinaryOperand.load(from: &pc))
        case 154: return .f32Min(Instruction.BinaryOperand.load(from: &pc))
        case 155: return .f64Min(Instruction.BinaryOperand.load(from: &pc))
        case 156: return .f32Max(Instruction.BinaryOperand.load(from: &pc))
        case 157: return .f64Max(Instruction.BinaryOperand.load(from: &pc))
        case 158: return .f32CopySign(Instruction.BinaryOperand.load(from: &pc))
        case 159: return .f64CopySign(Instruction.BinaryOperand.load(from: &pc))
        case 160: return .f32Eq(Instruction.BinaryOperand.load(from: &pc))
        case 161: return .f64Eq(Instruction.BinaryOperand.load(from: &pc))
        case 162: return .f32Ne(Instruction.BinaryOperand.load(from: &pc))
        case 163: return .f64Ne(Instruction.BinaryOperand.load(from: &pc))
        case 164: return .f32Lt(Instruction.BinaryOperand.load(from: &pc))
        case 165: return .f64Lt(Instruction.BinaryOperand.load(from: &pc))
        case 166: return .f32Gt(Instruction.BinaryOperand.load(from: &pc))
        case 167: return .f64Gt(Instruction.BinaryOperand.load(from: &pc))
        case 168: return .f32Le(Instruction.BinaryOperand.load(from: &pc))
        case 169: return .f64Le(Instruction.BinaryOperand.load(from: &pc))
        case 170: return .f32Ge(Instruction.BinaryOperand.load(from: &pc))
        case 171: return .f64Ge(Instruction.BinaryOperand.load(from: &pc))
        case 172: return .f32Abs(Instruction.UnaryOperand.load(from: &pc))
        case 173: return .f64Abs(Instruction.UnaryOperand.load(from: &pc))
        case 174: return .f32Neg(Instruction.UnaryOperand.load(from: &pc))
        case 175: return .f64Neg(Instruction.UnaryOperand.load(from: &pc))
        case 176: return .f32Ceil(Instruction.UnaryOperand.load(from: &pc))
        case 177: return .f64Ceil(Instruction.UnaryOperand.load(from: &pc))
        case 178: return .f32Floor(Instruction.UnaryOperand.load(from: &pc))
        case 179: return .f64Floor(Instruction.UnaryOperand.load(from: &pc))
        case 180: return .f32Trunc(Instruction.UnaryOperand.load(from: &pc))
        case 181: return .f64Trunc(Instruction.UnaryOperand.load(from: &pc))
        case 182: return .f32Nearest(Instruction.UnaryOperand.load(from: &pc))
        case 183: return .f64Nearest(Instruction.UnaryOperand.load(from: &pc))
        case 184: return .f32Sqrt(Instruction.UnaryOperand.load(from: &pc))
        case 185: return .f64Sqrt(Instruction.UnaryOperand.load(from: &pc))
        case 186: return .f64PromoteF32(Instruction.UnaryOperand.load(from: &pc))
        case 187: return .f32DemoteF64(Instruction.UnaryOperand.load(from: &pc))
        case 188: return .select(Instruction.SelectOperand.load(from: &pc))
        case 189: return .refNull(Instruction.RefNullOperand.load(from: &pc))
        case 190: return .refIsNull(Instruction.RefIsNullOperand.load(from: &pc))
        case 191: return .refFunc(Instruction.RefFuncOperand.load(from: &pc))
        case 192: return .tableGet(Instruction.TableGetOperand.load(from: &pc))
        case 193: return .tableSet(Instruction.TableSetOperand.load(from: &pc))
        case 194: return .tableSize(Instruction.TableSizeOperand.load(from: &pc))
        case 195: return .tableGrow(Instruction.TableGrowOperand.load(from: &pc))
        case 196: return .tableFill(Instruction.TableFillOperand.load(from: &pc))
        case 197: return .tableCopy(Instruction.TableCopyOperand.load(from: &pc))
        case 198: return .tableInit(Instruction.TableInitOperand.load(from: &pc))
        case 199: return .tableElementDrop(Instruction.TableElementDropOperand.load(from: &pc))
        case 200: return .onEnter(Instruction.OnEnterOperand.load(from: &pc))
        case 201: return .onExit(Instruction.OnExitOperand.load(from: &pc))
        case 202: return .breakpoint
        case 203: return .i32AtomicLoad(Instruction.LoadOperand.load(from: &pc))
        case 204: return .i64AtomicLoad(Instruction.LoadOperand.load(from: &pc))
        case 205: return .i32AtomicLoad8U(Instruction.LoadOperand.load(from: &pc))
        case 206: return .i32AtomicLoad16U(Instruction.LoadOperand.load(from: &pc))
        case 207: return .i64AtomicLoad8U(Instruction.LoadOperand.load(from: &pc))
        case 208: return .i64AtomicLoad16U(Instruction.LoadOperand.load(from: &pc))
        case 209: return .i64AtomicLoad32U(Instruction.LoadOperand.load(from: &pc))
        case 210: return .i32AtomicStore(Instruction.StoreOperand.load(from: &pc))
        case 211: return .i64AtomicStore(Instruction.StoreOperand.load(from: &pc))
        case 212: return .i32AtomicStore8(Instruction.StoreOperand.load(from: &pc))
        case 213: return .i32AtomicStore16(Instruction.StoreOperand.load(from: &pc))
        case 214: return .i64AtomicStore8(Instruction.StoreOperand.load(from: &pc))
        case 215: return .i64AtomicStore16(Instruction.StoreOperand.load(from: &pc))
        case 216: return .i64AtomicStore32(Instruction.StoreOperand.load(from: &pc))
        default: fatalError("Unknown instruction opcode: \(opcode)")
        }
    }
}

#if EngineStats
extension Instruction {
    /// The name of the instruction.
    /// - Parameter opcode: The opcode ID of the instruction.
    /// - Returns: The name of the instruction.
    ///
    /// NOTE: This function is used for debugging purposes.
    static func name(opcode: OpcodeID) -> String {
        switch opcode {
        case 0: return "copyStack"
        case 1: return "globalGet"
        case 2: return "globalSet"
        case 3: return "call"
        case 4: return "compilingCall"
        case 5: return "internalCall"
        case 6: return "callIndirect"
        case 7: return "resizeFrameHeader"
        case 8: return "returnCall"
        case 9: return "returnCallIndirect"
        case 10: return "unreachable"
        case 11: return "nop"
        case 12: return "br"
        case 13: return "brIf"
        case 14: return "brIfNot"
        case 15: return "brTable"
        case 16: return "_return"
        case 17: return "endOfExecution"
        case 18: return "i32Load"
        case 19: return "i64Load"
        case 20: return "f32Load"
        case 21: return "f64Load"
        case 22: return "i32Load8S"
        case 23: return "i32Load8U"
        case 24: return "i32Load16S"
        case 25: return "i32Load16U"
        case 26: return "i64Load8S"
        case 27: return "i64Load8U"
        case 28: return "i64Load16S"
        case 29: return "i64Load16U"
        case 30: return "i64Load32S"
        case 31: return "i64Load32U"
        case 32: return "i32Store"
        case 33: return "i64Store"
        case 34: return "f32Store"
        case 35: return "f64Store"
        case 36: return "i32Store8"
        case 37: return "i32Store16"
        case 38: return "i64Store8"
        case 39: return "i64Store16"
        case 40: return "i64Store32"
        case 41: return "memorySize"
        case 42: return "memoryGrow"
        case 43: return "memoryInit"
        case 44: return "memoryDataDrop"
        case 45: return "memoryCopy"
        case 46: return "memoryFill"
        case 47: return "v128Const"
        case 48: return "i8x16Shuffle"
        case 49: return "simd"
        case 50: return "const32"
        case 51: return "const64"
        case 52: return "i32Add"
        case 53: return "i64Add"
        case 54: return "i32Sub"
        case 55: return "i64Sub"
        case 56: return "i32Mul"
        case 57: return "i64Mul"
        case 58: return "i32And"
        case 59: return "i64And"
        case 60: return "i32Or"
        case 61: return "i64Or"
        case 62: return "i32Xor"
        case 63: return "i64Xor"
        case 64: return "i32Shl"
        case 65: return "i64Shl"
        case 66: return "i32ShrS"
        case 67: return "i64ShrS"
        case 68: return "i32ShrU"
        case 69: return "i64ShrU"
        case 70: return "i32Rotl"
        case 71: return "i64Rotl"
        case 72: return "i32Rotr"
        case 73: return "i64Rotr"
        case 74: return "i32DivS"
        case 75: return "i64DivS"
        case 76: return "i32DivU"
        case 77: return "i64DivU"
        case 78: return "i32RemS"
        case 79: return "i64RemS"
        case 80: return "i32RemU"
        case 81: return "i64RemU"
        case 82: return "i32Eq"
        case 83: return "i64Eq"
        case 84: return "i32Ne"
        case 85: return "i64Ne"
        case 86: return "i32LtS"
        case 87: return "i64LtS"
        case 88: return "i32LtU"
        case 89: return "i64LtU"
        case 90: return "i32GtS"
        case 91: return "i64GtS"
        case 92: return "i32GtU"
        case 93: return "i64GtU"
        case 94: return "i32LeS"
        case 95: return "i64LeS"
        case 96: return "i32LeU"
        case 97: return "i64LeU"
        case 98: return "i32GeS"
        case 99: return "i64GeS"
        case 100: return "i32GeU"
        case 101: return "i64GeU"
        case 102: return "i32Clz"
        case 103: return "i64Clz"
        case 104: return "i32Ctz"
        case 105: return "i64Ctz"
        case 106: return "i32Popcnt"
        case 107: return "i64Popcnt"
        case 108: return "i32Eqz"
        case 109: return "i64Eqz"
        case 110: return "i32WrapI64"
        case 111: return "i64ExtendI32S"
        case 112: return "i64ExtendI32U"
        case 113: return "i32Extend8S"
        case 114: return "i64Extend8S"
        case 115: return "i32Extend16S"
        case 116: return "i64Extend16S"
        case 117: return "i64Extend32S"
        case 118: return "i32TruncF32S"
        case 119: return "i32TruncF32U"
        case 120: return "i32TruncSatF32S"
        case 121: return "i32TruncSatF32U"
        case 122: return "i32TruncF64S"
        case 123: return "i32TruncF64U"
        case 124: return "i32TruncSatF64S"
        case 125: return "i32TruncSatF64U"
        case 126: return "i64TruncF32S"
        case 127: return "i64TruncF32U"
        case 128: return "i64TruncSatF32S"
        case 129: return "i64TruncSatF32U"
        case 130: return "i64TruncF64S"
        case 131: return "i64TruncF64U"
        case 132: return "i64TruncSatF64S"
        case 133: return "i64TruncSatF64U"
        case 134: return "f32ConvertI32S"
        case 135: return "f32ConvertI32U"
        case 136: return "f32ConvertI64S"
        case 137: return "f32ConvertI64U"
        case 138: return "f64ConvertI32S"
        case 139: return "f64ConvertI32U"
        case 140: return "f64ConvertI64S"
        case 141: return "f64ConvertI64U"
        case 142: return "f32ReinterpretI32"
        case 143: return "f64ReinterpretI64"
        case 144: return "i32ReinterpretF32"
        case 145: return "i64ReinterpretF64"
        case 146: return "f32Add"
        case 147: return "f64Add"
        case 148: return "f32Sub"
        case 149: return "f64Sub"
        case 150: return "f32Mul"
        case 151: return "f64Mul"
        case 152: return "f32Div"
        case 153: return "f64Div"
        case 154: return "f32Min"
        case 155: return "f64Min"
        case 156: return "f32Max"
        case 157: return "f64Max"
        case 158: return "f32CopySign"
        case 159: return "f64CopySign"
        case 160: return "f32Eq"
        case 161: return "f64Eq"
        case 162: return "f32Ne"
        case 163: return "f64Ne"
        case 164: return "f32Lt"
        case 165: return "f64Lt"
        case 166: return "f32Gt"
        case 167: return "f64Gt"
        case 168: return "f32Le"
        case 169: return "f64Le"
        case 170: return "f32Ge"
        case 171: return "f64Ge"
        case 172: return "f32Abs"
        case 173: return "f64Abs"
        case 174: return "f32Neg"
        case 175: return "f64Neg"
        case 176: return "f32Ceil"
        case 177: return "f64Ceil"
        case 178: return "f32Floor"
        case 179: return "f64Floor"
        case 180: return "f32Trunc"
        case 181: return "f64Trunc"
        case 182: return "f32Nearest"
        case 183: return "f64Nearest"
        case 184: return "f32Sqrt"
        case 185: return "f64Sqrt"
        case 186: return "f64PromoteF32"
        case 187: return "f32DemoteF64"
        case 188: return "select"
        case 189: return "refNull"
        case 190: return "refIsNull"
        case 191: return "refFunc"
        case 192: return "tableGet"
        case 193: return "tableSet"
        case 194: return "tableSize"
        case 195: return "tableGrow"
        case 196: return "tableFill"
        case 197: return "tableCopy"
        case 198: return "tableInit"
        case 199: return "tableElementDrop"
        case 200: return "onEnter"
        case 201: return "onExit"
        case 202: return "breakpoint"
        case 203: return "i32AtomicLoad"
        case 204: return "i64AtomicLoad"
        case 205: return "i32AtomicLoad8U"
        case 206: return "i32AtomicLoad16U"
        case 207: return "i64AtomicLoad8U"
        case 208: return "i64AtomicLoad16U"
        case 209: return "i64AtomicLoad32U"
        case 210: return "i32AtomicStore"
        case 211: return "i64AtomicStore"
        case 212: return "i32AtomicStore8"
        case 213: return "i32AtomicStore16"
        case 214: return "i64AtomicStore8"
        case 215: return "i64AtomicStore16"
        case 216: return "i64AtomicStore32"
        default: fatalError("Unknown instruction index: \(opcode)")
        }
    }
}
#endif // EngineStats
