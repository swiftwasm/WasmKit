// This file is generated by Utilities/generate_inst_dispatch.swift
extension ExecutionState {
    @inline(__always)
    mutating func doExecute(_ instruction: Instruction, md: inout Md, ms: inout Ms, context: inout StackContext, sp: Sp) throws -> Bool {
        switch instruction {
        case .copyStack(let copyStackOperand):
            self.copyStack(context: &context, sp: sp, copyStackOperand: copyStackOperand)
        case .globalGet(let globalGetOperand):
            try self.globalGet(context: &context, sp: sp, globalGetOperand: globalGetOperand)
        case .globalSet(let globalSetOperand):
            try self.globalSet(context: &context, sp: sp, globalSetOperand: globalSetOperand)
        case .call(let callOperand):
            try self.call(context: &context, sp: sp, md: &md, ms: &ms, callOperand: callOperand)
            return false
        case .compilingCall(let compilingCallOperand):
            try self.compilingCall(context: &context, sp: sp, compilingCallOperand: compilingCallOperand)
            return false
        case .internalCall(let internalCallOperand):
            try self.internalCall(context: &context, sp: sp, internalCallOperand: internalCallOperand)
            return false
        case .callIndirect(let callIndirectOperand):
            try self.callIndirect(context: &context, sp: sp, md: &md, ms: &ms, callIndirectOperand: callIndirectOperand)
            return false
        case .unreachable:
            try self.unreachable(context: &context, sp: sp)
            return true
        case .nop:
            try self.nop(context: &context, sp: sp)
            return true
        case .ifThen(let ifOperand):
            self.ifThen(context: &context, sp: sp, ifOperand: ifOperand)
            return true
        case .br(let offset):
            try self.br(context: &context, sp: sp, offset: offset)
            return true
        case .brIfNot(let brIfOperand):
            try self.brIfNot(context: &context, sp: sp, brIfOperand: brIfOperand)
            return true
        case .brTable(let brTableOperand):
            try self.brTable(context: &context, sp: sp, brTableOperand: brTableOperand)
            return true
        case .`return`(let returnOperand):
            try self.`return`(context: &context, sp: sp, md: &md, ms: &ms, returnOperand: returnOperand)
            return false
        case .endOfFunction(let returnOperand):
            try self.endOfFunction(context: &context, sp: sp, md: &md, ms: &ms, returnOperand: returnOperand)
            return false
        case .endOfExecution:
            try self.endOfExecution(context: &context, sp: sp)
            return false
        case .i32Load(let loadOperand):
            try self.i32Load(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load(let loadOperand):
            try self.i64Load(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .f32Load(let loadOperand):
            try self.f32Load(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .f64Load(let loadOperand):
            try self.f64Load(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load8S(let loadOperand):
            try self.i32Load8S(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load8U(let loadOperand):
            try self.i32Load8U(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load16S(let loadOperand):
            try self.i32Load16S(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load16U(let loadOperand):
            try self.i32Load16U(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load8S(let loadOperand):
            try self.i64Load8S(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load8U(let loadOperand):
            try self.i64Load8U(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load16S(let loadOperand):
            try self.i64Load16S(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load16U(let loadOperand):
            try self.i64Load16U(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load32S(let loadOperand):
            try self.i64Load32S(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load32U(let loadOperand):
            try self.i64Load32U(context: &context, sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Store(let storeOperand):
            try self.i32Store(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store(let storeOperand):
            try self.i64Store(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .f32Store(let storeOperand):
            try self.f32Store(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .f64Store(let storeOperand):
            try self.f64Store(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i32Store8(let storeOperand):
            try self.i32Store8(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i32Store16(let storeOperand):
            try self.i32Store16(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store8(let storeOperand):
            try self.i64Store8(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store16(let storeOperand):
            try self.i64Store16(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store32(let storeOperand):
            try self.i64Store32(context: &context, sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .memorySize(let memorySizeOperand):
            self.memorySize(context: &context, sp: sp, memorySizeOperand: memorySizeOperand)
        case .memoryGrow(let memoryGrowOperand):
            try self.memoryGrow(context: &context, sp: sp, md: &md, ms: &ms, memoryGrowOperand: memoryGrowOperand)
        case .memoryInit(let memoryInitOperand):
            try self.memoryInit(context: &context, sp: sp, memoryInitOperand: memoryInitOperand)
        case .memoryDataDrop(let dataIndex):
            self.memoryDataDrop(context: &context, sp: sp, dataIndex: dataIndex)
        case .memoryCopy(let memoryCopyOperand):
            try self.memoryCopy(context: &context, sp: sp, memoryCopyOperand: memoryCopyOperand)
        case .memoryFill(let memoryFillOperand):
            try self.memoryFill(context: &context, sp: sp, memoryFillOperand: memoryFillOperand)
        case .numericConst(let constOperand):
            self.numericConst(context: &context, sp: sp, constOperand: constOperand)
        case .numericFloatUnary(let floatUnary, let unaryOperand):
            self.numericFloatUnary(context: &context, sp: sp, floatUnary: floatUnary, unaryOperand: unaryOperand)
        case .numericIntBinary(let intBinary, let binaryOperand):
            try self.numericIntBinary(context: &context, sp: sp, intBinary: intBinary, binaryOperand: binaryOperand)
        case .numericFloatBinary(let floatBinary, let binaryOperand):
            self.numericFloatBinary(context: &context, sp: sp, floatBinary: floatBinary, binaryOperand: binaryOperand)
        case .numericConversion(let conversion, let unaryOperand):
            try self.numericConversion(context: &context, sp: sp, conversion: conversion, unaryOperand: unaryOperand)
        case .i32Add(let binaryOperand):
            self.i32Add(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Add(let binaryOperand):
            self.i64Add(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f32Add(let binaryOperand):
            self.f32Add(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f64Add(let binaryOperand):
            self.f64Add(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Sub(let binaryOperand):
            self.i32Sub(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Sub(let binaryOperand):
            self.i64Sub(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f32Sub(let binaryOperand):
            self.f32Sub(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f64Sub(let binaryOperand):
            self.f64Sub(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Mul(let binaryOperand):
            self.i32Mul(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Mul(let binaryOperand):
            self.i64Mul(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f32Mul(let binaryOperand):
            self.f32Mul(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f64Mul(let binaryOperand):
            self.f64Mul(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Eq(let binaryOperand):
            self.i32Eq(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Eq(let binaryOperand):
            self.i64Eq(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f32Eq(let binaryOperand):
            self.f32Eq(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f64Eq(let binaryOperand):
            self.f64Eq(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Ne(let binaryOperand):
            self.i32Ne(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Ne(let binaryOperand):
            self.i64Ne(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f32Ne(let binaryOperand):
            self.f32Ne(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .f64Ne(let binaryOperand):
            self.f64Ne(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32LtS(let binaryOperand):
            self.i32LtS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64LtS(let binaryOperand):
            self.i64LtS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32LtU(let binaryOperand):
            self.i32LtU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64LtU(let binaryOperand):
            self.i64LtU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32GtS(let binaryOperand):
            self.i32GtS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64GtS(let binaryOperand):
            self.i64GtS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32GtU(let binaryOperand):
            self.i32GtU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64GtU(let binaryOperand):
            self.i64GtU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32LeS(let binaryOperand):
            self.i32LeS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64LeS(let binaryOperand):
            self.i64LeS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32LeU(let binaryOperand):
            self.i32LeU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64LeU(let binaryOperand):
            self.i64LeU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32GeS(let binaryOperand):
            self.i32GeS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64GeS(let binaryOperand):
            self.i64GeS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32GeU(let binaryOperand):
            self.i32GeU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64GeU(let binaryOperand):
            self.i64GeU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32And(let binaryOperand):
            self.i32And(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64And(let binaryOperand):
            self.i64And(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Or(let binaryOperand):
            self.i32Or(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Or(let binaryOperand):
            self.i64Or(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Xor(let binaryOperand):
            self.i32Xor(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Xor(let binaryOperand):
            self.i64Xor(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Shl(let binaryOperand):
            self.i32Shl(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Shl(let binaryOperand):
            self.i64Shl(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32ShrS(let binaryOperand):
            self.i32ShrS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64ShrS(let binaryOperand):
            self.i64ShrS(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32ShrU(let binaryOperand):
            self.i32ShrU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64ShrU(let binaryOperand):
            self.i64ShrU(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Rotl(let binaryOperand):
            self.i32Rotl(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Rotl(let binaryOperand):
            self.i64Rotl(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Rotr(let binaryOperand):
            self.i32Rotr(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i64Rotr(let binaryOperand):
            self.i64Rotr(context: &context, sp: sp, binaryOperand: binaryOperand)
        case .i32Clz(let unaryOperand):
            self.i32Clz(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i64Clz(let unaryOperand):
            self.i64Clz(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i32Ctz(let unaryOperand):
            self.i32Ctz(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i64Ctz(let unaryOperand):
            self.i64Ctz(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i32Popcnt(let unaryOperand):
            self.i32Popcnt(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i64Popcnt(let unaryOperand):
            self.i64Popcnt(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i32Eqz(let unaryOperand):
            self.i32Eqz(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .i64Eqz(let unaryOperand):
            self.i64Eqz(context: &context, sp: sp, unaryOperand: unaryOperand)
        case .select(let selectOperand):
            try self.select(context: &context, sp: sp, selectOperand: selectOperand)
        case .refNull(let refNullOperand):
            self.refNull(context: &context, sp: sp, refNullOperand: refNullOperand)
        case .refIsNull(let refIsNullOperand):
            self.refIsNull(context: &context, sp: sp, refIsNullOperand: refIsNullOperand)
        case .refFunc(let refFuncOperand):
            self.refFunc(context: &context, sp: sp, refFuncOperand: refFuncOperand)
        case .tableGet(let tableGetOperand):
            try self.tableGet(context: &context, sp: sp, tableGetOperand: tableGetOperand)
        case .tableSet(let tableSetOperand):
            try self.tableSet(context: &context, sp: sp, tableSetOperand: tableSetOperand)
        case .tableSize(let tableSizeOperand):
            self.tableSize(context: &context, sp: sp, tableSizeOperand: tableSizeOperand)
        case .tableGrow(let tableGrowOperand):
            self.tableGrow(context: &context, sp: sp, tableGrowOperand: tableGrowOperand)
        case .tableFill(let tableFillOperand):
            try self.tableFill(context: &context, sp: sp, tableFillOperand: tableFillOperand)
        case .tableCopy(let tableCopyOperand):
            try self.tableCopy(context: &context, sp: sp, tableCopyOperand: tableCopyOperand)
        case .tableInit(let tableInitOperand):
            try self.tableInit(context: &context, sp: sp, tableInitOperand: tableInitOperand)
        case .tableElementDrop(let elementIndex):
            self.tableElementDrop(context: &context, sp: sp, elementIndex: elementIndex)
        }
        programCounter += 1
        return true
    }
}

extension Instruction {
    var name: String {
        switch self {
        case .copyStack: return "copyStack"
        case .globalGet: return "globalGet"
        case .globalSet: return "globalSet"
        case .call: return "call"
        case .compilingCall: return "compilingCall"
        case .internalCall: return "internalCall"
        case .callIndirect: return "callIndirect"
        case .unreachable: return "unreachable"
        case .nop: return "nop"
        case .ifThen: return "ifThen"
        case .br: return "br"
        case .brIfNot: return "brIfNot"
        case .brTable: return "brTable"
        case .`return`: return "`return`"
        case .endOfFunction: return "endOfFunction"
        case .endOfExecution: return "endOfExecution"
        case .i32Load: return "i32Load"
        case .i64Load: return "i64Load"
        case .f32Load: return "f32Load"
        case .f64Load: return "f64Load"
        case .i32Load8S: return "i32Load8S"
        case .i32Load8U: return "i32Load8U"
        case .i32Load16S: return "i32Load16S"
        case .i32Load16U: return "i32Load16U"
        case .i64Load8S: return "i64Load8S"
        case .i64Load8U: return "i64Load8U"
        case .i64Load16S: return "i64Load16S"
        case .i64Load16U: return "i64Load16U"
        case .i64Load32S: return "i64Load32S"
        case .i64Load32U: return "i64Load32U"
        case .i32Store: return "i32Store"
        case .i64Store: return "i64Store"
        case .f32Store: return "f32Store"
        case .f64Store: return "f64Store"
        case .i32Store8: return "i32Store8"
        case .i32Store16: return "i32Store16"
        case .i64Store8: return "i64Store8"
        case .i64Store16: return "i64Store16"
        case .i64Store32: return "i64Store32"
        case .memorySize: return "memorySize"
        case .memoryGrow: return "memoryGrow"
        case .memoryInit: return "memoryInit"
        case .memoryDataDrop: return "memoryDataDrop"
        case .memoryCopy: return "memoryCopy"
        case .memoryFill: return "memoryFill"
        case .numericConst: return "numericConst"
        case .numericFloatUnary: return "numericFloatUnary"
        case .numericIntBinary: return "numericIntBinary"
        case .numericFloatBinary: return "numericFloatBinary"
        case .numericConversion: return "numericConversion"
        case .i32Add: return "i32Add"
        case .i64Add: return "i64Add"
        case .f32Add: return "f32Add"
        case .f64Add: return "f64Add"
        case .i32Sub: return "i32Sub"
        case .i64Sub: return "i64Sub"
        case .f32Sub: return "f32Sub"
        case .f64Sub: return "f64Sub"
        case .i32Mul: return "i32Mul"
        case .i64Mul: return "i64Mul"
        case .f32Mul: return "f32Mul"
        case .f64Mul: return "f64Mul"
        case .i32Eq: return "i32Eq"
        case .i64Eq: return "i64Eq"
        case .f32Eq: return "f32Eq"
        case .f64Eq: return "f64Eq"
        case .i32Ne: return "i32Ne"
        case .i64Ne: return "i64Ne"
        case .f32Ne: return "f32Ne"
        case .f64Ne: return "f64Ne"
        case .i32LtS: return "i32LtS"
        case .i64LtS: return "i64LtS"
        case .i32LtU: return "i32LtU"
        case .i64LtU: return "i64LtU"
        case .i32GtS: return "i32GtS"
        case .i64GtS: return "i64GtS"
        case .i32GtU: return "i32GtU"
        case .i64GtU: return "i64GtU"
        case .i32LeS: return "i32LeS"
        case .i64LeS: return "i64LeS"
        case .i32LeU: return "i32LeU"
        case .i64LeU: return "i64LeU"
        case .i32GeS: return "i32GeS"
        case .i64GeS: return "i64GeS"
        case .i32GeU: return "i32GeU"
        case .i64GeU: return "i64GeU"
        case .i32And: return "i32And"
        case .i64And: return "i64And"
        case .i32Or: return "i32Or"
        case .i64Or: return "i64Or"
        case .i32Xor: return "i32Xor"
        case .i64Xor: return "i64Xor"
        case .i32Shl: return "i32Shl"
        case .i64Shl: return "i64Shl"
        case .i32ShrS: return "i32ShrS"
        case .i64ShrS: return "i64ShrS"
        case .i32ShrU: return "i32ShrU"
        case .i64ShrU: return "i64ShrU"
        case .i32Rotl: return "i32Rotl"
        case .i64Rotl: return "i64Rotl"
        case .i32Rotr: return "i32Rotr"
        case .i64Rotr: return "i64Rotr"
        case .i32Clz: return "i32Clz"
        case .i64Clz: return "i64Clz"
        case .i32Ctz: return "i32Ctz"
        case .i64Ctz: return "i64Ctz"
        case .i32Popcnt: return "i32Popcnt"
        case .i64Popcnt: return "i64Popcnt"
        case .i32Eqz: return "i32Eqz"
        case .i64Eqz: return "i64Eqz"
        case .select: return "select"
        case .refNull: return "refNull"
        case .refIsNull: return "refIsNull"
        case .refFunc: return "refFunc"
        case .tableGet: return "tableGet"
        case .tableSet: return "tableSet"
        case .tableSize: return "tableSize"
        case .tableGrow: return "tableGrow"
        case .tableFill: return "tableFill"
        case .tableCopy: return "tableCopy"
        case .tableInit: return "tableInit"
        case .tableElementDrop: return "tableElementDrop"
        }
    }
}


extension ExecutionState {
    mutating func i32Add(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.add(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Add(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.add(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func f32Add(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f32.add(sp[binaryOperand.rhs].f32).untyped
    }
    mutating func f64Add(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f64.add(sp[binaryOperand.rhs].f64).untyped
    }
    mutating func i32Sub(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.sub(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Sub(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.sub(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func f32Sub(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f32.sub(sp[binaryOperand.rhs].f32).untyped
    }
    mutating func f64Sub(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f64.sub(sp[binaryOperand.rhs].f64).untyped
    }
    mutating func i32Mul(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.mul(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Mul(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.mul(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func f32Mul(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f32.mul(sp[binaryOperand.rhs].f32).untyped
    }
    mutating func f64Mul(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f64.mul(sp[binaryOperand.rhs].f64).untyped
    }
    mutating func i32Eq(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.eq(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Eq(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.eq(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func f32Eq(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f32.eq(sp[binaryOperand.rhs].f32).untyped
    }
    mutating func f64Eq(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f64.eq(sp[binaryOperand.rhs].f64).untyped
    }
    mutating func i32Ne(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.ne(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Ne(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.ne(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func f32Ne(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f32.ne(sp[binaryOperand.rhs].f32).untyped
    }
    mutating func f64Ne(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].f64.ne(sp[binaryOperand.rhs].f64).untyped
    }
    mutating func i32LtS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.lts(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64LtS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.lts(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32LtU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.ltu(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64LtU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.ltu(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32GtS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.gts(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64GtS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.gts(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32GtU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.gtu(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64GtU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.gtu(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32LeS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.les(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64LeS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.les(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32LeU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.leu(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64LeU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.leu(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32GeS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.ges(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64GeS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.ges(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32GeU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.geu(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64GeU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.geu(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32And(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.and(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64And(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.and(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32Or(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.or(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Or(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.or(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32Xor(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.xor(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Xor(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.xor(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32Shl(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.shl(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Shl(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.shl(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32ShrS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.shrs(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64ShrS(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.shrs(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32ShrU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.shru(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64ShrU(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.shru(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32Rotl(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.rotl(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Rotl(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.rotl(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32Rotr(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i32.rotr(sp[binaryOperand.rhs].i32).untyped
    }
    mutating func i64Rotr(context: inout StackContext, sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[binaryOperand.result] = sp[binaryOperand.lhs].i64.rotr(sp[binaryOperand.rhs].i64).untyped
    }
    mutating func i32Clz(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i32.clz.untyped
    }
    mutating func i64Clz(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i64.clz.untyped
    }
    mutating func i32Ctz(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i32.ctz.untyped
    }
    mutating func i64Ctz(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i64.ctz.untyped
    }
    mutating func i32Popcnt(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i32.popcnt.untyped
    }
    mutating func i64Popcnt(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i64.popcnt.untyped
    }
    mutating func i32Eqz(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i32.eqz.untyped
    }
    mutating func i64Eqz(context: inout StackContext, sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[unaryOperand.result] = sp[unaryOperand.input].i64.eqz.untyped
    }
    mutating func i32Load(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt32.self, castToValue: { .i32($0) })
    }
    mutating func i64Load(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt64.self, castToValue: { .i64($0) })
    }
    mutating func f32Load(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt32.self, castToValue: { .rawF32($0) })
    }
    mutating func f64Load(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt64.self, castToValue: { .rawF64($0) })
    }
    mutating func i32Load8S(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int8.self, castToValue: { .init(signed: Int32($0)) })
    }
    mutating func i32Load8U(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt8.self, castToValue: { .i32(UInt32($0)) })
    }
    mutating func i32Load16S(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int16.self, castToValue: { .init(signed: Int32($0)) })
    }
    mutating func i32Load16U(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt16.self, castToValue: { .i32(UInt32($0)) })
    }
    mutating func i64Load8S(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int8.self, castToValue: { .init(signed: Int64($0)) })
    }
    mutating func i64Load8U(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt8.self, castToValue: { .i64(UInt64($0)) })
    }
    mutating func i64Load16S(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int16.self, castToValue: { .init(signed: Int64($0)) })
    }
    mutating func i64Load16U(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt16.self, castToValue: { .i64(UInt64($0)) })
    }
    mutating func i64Load32S(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int32.self, castToValue: { .init(signed: Int64($0)) })
    }
    mutating func i64Load32U(context: inout StackContext, sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt32.self, castToValue: { .i64(UInt64($0)) })
    }
    mutating func i32Store(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.i32 })
    }
    mutating func i64Store(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.i64 })
    }
    mutating func f32Store(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.rawF32 })
    }
    mutating func f64Store(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.rawF64 })
    }
    mutating func i32Store8(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt8(truncatingIfNeeded: $0.i32) })
    }
    mutating func i32Store16(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt16(truncatingIfNeeded: $0.i32) })
    }
    mutating func i64Store8(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt8(truncatingIfNeeded: $0.i64) })
    }
    mutating func i64Store16(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt16(truncatingIfNeeded: $0.i64) })
    }
    mutating func i64Store32(context: inout StackContext, sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt32(truncatingIfNeeded: $0.i64) })
    }
}
