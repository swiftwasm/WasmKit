// swift-format-ignore-file
//// Automatically generated by Utilities/Sources/WasmGen.swift
//// DO NOT EDIT DIRECTLY

import WasmParser
import WasmTypes

/// An instruction encoder that is responsible for encoding opcodes and immediates
/// in Wasm binary format.
protocol BinaryInstructionEncoder: InstructionVisitor {
    /// Encodes an instruction opcode.
    mutating func encodeInstruction(_ opcode: [UInt8]) throws(WasmKitError)

    // MARK: - Immediates encoding
    mutating func encodeImmediates(blockType: BlockType) throws(WasmKitError)
    mutating func encodeImmediates(dataIndex: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(elemIndex: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(functionIndex: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(globalIndex: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(lane: UInt8) throws(WasmKitError)
    mutating func encodeImmediates(lanes: V128ShuffleMask) throws(WasmKitError)
    mutating func encodeImmediates(localIndex: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(memarg: MemArg) throws(WasmKitError)
    mutating func encodeImmediates(memory: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(relativeDepth: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(table: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(targets: BrTable) throws(WasmKitError)
    mutating func encodeImmediates(type: HeapType) throws(WasmKitError)
    mutating func encodeImmediates(type: ValueType) throws(WasmKitError)
    mutating func encodeImmediates(typeIndex: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(value: IEEE754.Float32) throws(WasmKitError)
    mutating func encodeImmediates(value: IEEE754.Float64) throws(WasmKitError)
    mutating func encodeImmediates(value: Int32) throws(WasmKitError)
    mutating func encodeImmediates(value: Int64) throws(WasmKitError)
    mutating func encodeImmediates(value: V128) throws(WasmKitError)
    mutating func encodeImmediates(dstMem: UInt32, srcMem: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(dstTable: UInt32, srcTable: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(elemIndex: UInt32, table: UInt32) throws(WasmKitError)
    mutating func encodeImmediates(memarg: MemArg, lane: UInt8) throws(WasmKitError)
    mutating func encodeImmediates(typeIndex: UInt32, tableIndex: UInt32) throws(WasmKitError)
}

// BinaryInstructionEncoder implements the InstructionVisitor protocol to call the corresponding encode method.
extension BinaryInstructionEncoder {
    mutating func visitUnreachable() throws(WasmKitError) { try encodeInstruction([0x00]) }
    mutating func visitNop() throws(WasmKitError) { try encodeInstruction([0x01]) }
    mutating func visitBlock(blockType: BlockType) throws(WasmKitError) {
        try encodeInstruction([0x02])
        try encodeImmediates(blockType: blockType)
    }
    mutating func visitLoop(blockType: BlockType) throws(WasmKitError) {
        try encodeInstruction([0x03])
        try encodeImmediates(blockType: blockType)
    }
    mutating func visitIf(blockType: BlockType) throws(WasmKitError) {
        try encodeInstruction([0x04])
        try encodeImmediates(blockType: blockType)
    }
    mutating func visitElse() throws(WasmKitError) { try encodeInstruction([0x05]) }
    mutating func visitEnd() throws(WasmKitError) { try encodeInstruction([0x0B]) }
    mutating func visitBr(relativeDepth: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x0C])
        try encodeImmediates(relativeDepth: relativeDepth)
    }
    mutating func visitBrIf(relativeDepth: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x0D])
        try encodeImmediates(relativeDepth: relativeDepth)
    }
    mutating func visitBrTable(targets: BrTable) throws(WasmKitError) {
        try encodeInstruction([0x0E])
        try encodeImmediates(targets: targets)
    }
    mutating func visitReturn() throws(WasmKitError) { try encodeInstruction([0x0F]) }
    mutating func visitCall(functionIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x10])
        try encodeImmediates(functionIndex: functionIndex)
    }
    mutating func visitCallIndirect(typeIndex: UInt32, tableIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x11])
        try encodeImmediates(typeIndex: typeIndex, tableIndex: tableIndex)
    }
    mutating func visitReturnCall(functionIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x12])
        try encodeImmediates(functionIndex: functionIndex)
    }
    mutating func visitReturnCallIndirect(typeIndex: UInt32, tableIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x13])
        try encodeImmediates(typeIndex: typeIndex, tableIndex: tableIndex)
    }
    mutating func visitCallRef(typeIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x14])
        try encodeImmediates(typeIndex: typeIndex)
    }
    mutating func visitReturnCallRef(typeIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x15])
        try encodeImmediates(typeIndex: typeIndex)
    }
    mutating func visitDrop() throws(WasmKitError) { try encodeInstruction([0x1A]) }
    mutating func visitSelect() throws(WasmKitError) { try encodeInstruction([0x1B]) }
    mutating func visitTypedSelect(type: ValueType) throws(WasmKitError) {
        try encodeInstruction([0x1C])
        try encodeImmediates(type: type)
    }
    mutating func visitLocalGet(localIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x20])
        try encodeImmediates(localIndex: localIndex)
    }
    mutating func visitLocalSet(localIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x21])
        try encodeImmediates(localIndex: localIndex)
    }
    mutating func visitLocalTee(localIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x22])
        try encodeImmediates(localIndex: localIndex)
    }
    mutating func visitGlobalGet(globalIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x23])
        try encodeImmediates(globalIndex: globalIndex)
    }
    mutating func visitGlobalSet(globalIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x24])
        try encodeImmediates(globalIndex: globalIndex)
    }
    mutating func visitLoad(_ load: Instruction.Load, memarg: MemArg) throws(WasmKitError) {
        let opcode: [UInt8]
        switch load {
        case .i32Load: opcode = [0x28]
        case .i64Load: opcode = [0x29]
        case .f32Load: opcode = [0x2A]
        case .f64Load: opcode = [0x2B]
        case .i32Load8S: opcode = [0x2C]
        case .i32Load8U: opcode = [0x2D]
        case .i32Load16S: opcode = [0x2E]
        case .i32Load16U: opcode = [0x2F]
        case .i64Load8S: opcode = [0x30]
        case .i64Load8U: opcode = [0x31]
        case .i64Load16S: opcode = [0x32]
        case .i64Load16U: opcode = [0x33]
        case .i64Load32S: opcode = [0x34]
        case .i64Load32U: opcode = [0x35]
        case .i32AtomicLoad: opcode = [0xFE, 0x10]
        case .i64AtomicLoad: opcode = [0xFE, 0x11]
        case .i32AtomicLoad8U: opcode = [0xFE, 0x12]
        case .i32AtomicLoad16U: opcode = [0xFE, 0x13]
        case .i64AtomicLoad8U: opcode = [0xFE, 0x14]
        case .i64AtomicLoad16U: opcode = [0xFE, 0x15]
        case .i64AtomicLoad32U: opcode = [0xFE, 0x16]
        case .v128Load: opcode = [0xFD, 0x00]
        case .v128Load8X8S: opcode = [0xFD, 0x01]
        case .v128Load8X8U: opcode = [0xFD, 0x02]
        case .v128Load16X4S: opcode = [0xFD, 0x03]
        case .v128Load16X4U: opcode = [0xFD, 0x04]
        case .v128Load32X2S: opcode = [0xFD, 0x05]
        case .v128Load32X2U: opcode = [0xFD, 0x06]
        case .v128Load8Splat: opcode = [0xFD, 0x07]
        case .v128Load16Splat: opcode = [0xFD, 0x08]
        case .v128Load32Splat: opcode = [0xFD, 0x09]
        case .v128Load64Splat: opcode = [0xFD, 0x0A]
        case .v128Load32Zero: opcode = [0xFD, 0x5C]
        case .v128Load64Zero: opcode = [0xFD, 0x5D]
        }

        try encodeInstruction(opcode)
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitStore(_ store: Instruction.Store, memarg: MemArg) throws(WasmKitError) {
        let opcode: [UInt8]
        switch store {
        case .i32Store: opcode = [0x36]
        case .i64Store: opcode = [0x37]
        case .f32Store: opcode = [0x38]
        case .f64Store: opcode = [0x39]
        case .i32Store8: opcode = [0x3A]
        case .i32Store16: opcode = [0x3B]
        case .i64Store8: opcode = [0x3C]
        case .i64Store16: opcode = [0x3D]
        case .i64Store32: opcode = [0x3E]
        case .i32AtomicStore: opcode = [0xFE, 0x17]
        case .i64AtomicStore: opcode = [0xFE, 0x18]
        case .i32AtomicStore8: opcode = [0xFE, 0x19]
        case .i32AtomicStore16: opcode = [0xFE, 0x1A]
        case .i64AtomicStore8: opcode = [0xFE, 0x1B]
        case .i64AtomicStore16: opcode = [0xFE, 0x1C]
        case .i64AtomicStore32: opcode = [0xFE, 0x1D]
        case .v128Store: opcode = [0xFD, 0x0B]
        }

        try encodeInstruction(opcode)
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitMemorySize(memory: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x3F])
        try encodeImmediates(memory: memory)
    }
    mutating func visitMemoryGrow(memory: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x40])
        try encodeImmediates(memory: memory)
    }
    mutating func visitI32Const(value: Int32) throws(WasmKitError) {
        try encodeInstruction([0x41])
        try encodeImmediates(value: value)
    }
    mutating func visitI64Const(value: Int64) throws(WasmKitError) {
        try encodeInstruction([0x42])
        try encodeImmediates(value: value)
    }
    mutating func visitF32Const(value: IEEE754.Float32) throws(WasmKitError) {
        try encodeInstruction([0x43])
        try encodeImmediates(value: value)
    }
    mutating func visitF64Const(value: IEEE754.Float64) throws(WasmKitError) {
        try encodeInstruction([0x44])
        try encodeImmediates(value: value)
    }
    mutating func visitRefNull(type: HeapType) throws(WasmKitError) {
        try encodeInstruction([0xD0])
        try encodeImmediates(type: type)
    }
    mutating func visitRefIsNull() throws(WasmKitError) { try encodeInstruction([0xD1]) }
    mutating func visitRefFunc(functionIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xD2])
        try encodeImmediates(functionIndex: functionIndex)
    }
    mutating func visitRefAsNonNull() throws(WasmKitError) { try encodeInstruction([0xD4]) }
    mutating func visitBrOnNull(relativeDepth: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xD5])
        try encodeImmediates(relativeDepth: relativeDepth)
    }
    mutating func visitBrOnNonNull(relativeDepth: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xD6])
        try encodeImmediates(relativeDepth: relativeDepth)
    }
    mutating func visitI32Eqz() throws(WasmKitError) { try encodeInstruction([0x45]) }
    mutating func visitCmp(_ cmp: Instruction.Cmp) throws(WasmKitError) {
        let opcode: [UInt8]
        switch cmp {
        case .i32Eq: opcode = [0x46]
        case .i32Ne: opcode = [0x47]
        case .i32LtS: opcode = [0x48]
        case .i32LtU: opcode = [0x49]
        case .i32GtS: opcode = [0x4A]
        case .i32GtU: opcode = [0x4B]
        case .i32LeS: opcode = [0x4C]
        case .i32LeU: opcode = [0x4D]
        case .i32GeS: opcode = [0x4E]
        case .i32GeU: opcode = [0x4F]
        case .i64Eq: opcode = [0x51]
        case .i64Ne: opcode = [0x52]
        case .i64LtS: opcode = [0x53]
        case .i64LtU: opcode = [0x54]
        case .i64GtS: opcode = [0x55]
        case .i64GtU: opcode = [0x56]
        case .i64LeS: opcode = [0x57]
        case .i64LeU: opcode = [0x58]
        case .i64GeS: opcode = [0x59]
        case .i64GeU: opcode = [0x5A]
        case .f32Eq: opcode = [0x5B]
        case .f32Ne: opcode = [0x5C]
        case .f32Lt: opcode = [0x5D]
        case .f32Gt: opcode = [0x5E]
        case .f32Le: opcode = [0x5F]
        case .f32Ge: opcode = [0x60]
        case .f64Eq: opcode = [0x61]
        case .f64Ne: opcode = [0x62]
        case .f64Lt: opcode = [0x63]
        case .f64Gt: opcode = [0x64]
        case .f64Le: opcode = [0x65]
        case .f64Ge: opcode = [0x66]
        }

        try encodeInstruction(opcode)
    }
    mutating func visitI64Eqz() throws(WasmKitError) { try encodeInstruction([0x50]) }
    mutating func visitUnary(_ unary: Instruction.Unary) throws(WasmKitError) {
        let opcode: [UInt8]
        switch unary {
        case .i32Clz: opcode = [0x67]
        case .i32Ctz: opcode = [0x68]
        case .i32Popcnt: opcode = [0x69]
        case .i64Clz: opcode = [0x79]
        case .i64Ctz: opcode = [0x7A]
        case .i64Popcnt: opcode = [0x7B]
        case .f32Abs: opcode = [0x8B]
        case .f32Neg: opcode = [0x8C]
        case .f32Ceil: opcode = [0x8D]
        case .f32Floor: opcode = [0x8E]
        case .f32Trunc: opcode = [0x8F]
        case .f32Nearest: opcode = [0x90]
        case .f32Sqrt: opcode = [0x91]
        case .f64Abs: opcode = [0x99]
        case .f64Neg: opcode = [0x9A]
        case .f64Ceil: opcode = [0x9B]
        case .f64Floor: opcode = [0x9C]
        case .f64Trunc: opcode = [0x9D]
        case .f64Nearest: opcode = [0x9E]
        case .f64Sqrt: opcode = [0x9F]
        case .i32Extend8S: opcode = [0xC0]
        case .i32Extend16S: opcode = [0xC1]
        case .i64Extend8S: opcode = [0xC2]
        case .i64Extend16S: opcode = [0xC3]
        case .i64Extend32S: opcode = [0xC4]
        }

        try encodeInstruction(opcode)
    }
    mutating func visitBinary(_ binary: Instruction.Binary) throws(WasmKitError) {
        let opcode: [UInt8]
        switch binary {
        case .i32Add: opcode = [0x6A]
        case .i32Sub: opcode = [0x6B]
        case .i32Mul: opcode = [0x6C]
        case .i32DivS: opcode = [0x6D]
        case .i32DivU: opcode = [0x6E]
        case .i32RemS: opcode = [0x6F]
        case .i32RemU: opcode = [0x70]
        case .i32And: opcode = [0x71]
        case .i32Or: opcode = [0x72]
        case .i32Xor: opcode = [0x73]
        case .i32Shl: opcode = [0x74]
        case .i32ShrS: opcode = [0x75]
        case .i32ShrU: opcode = [0x76]
        case .i32Rotl: opcode = [0x77]
        case .i32Rotr: opcode = [0x78]
        case .i64Add: opcode = [0x7C]
        case .i64Sub: opcode = [0x7D]
        case .i64Mul: opcode = [0x7E]
        case .i64DivS: opcode = [0x7F]
        case .i64DivU: opcode = [0x80]
        case .i64RemS: opcode = [0x81]
        case .i64RemU: opcode = [0x82]
        case .i64And: opcode = [0x83]
        case .i64Or: opcode = [0x84]
        case .i64Xor: opcode = [0x85]
        case .i64Shl: opcode = [0x86]
        case .i64ShrS: opcode = [0x87]
        case .i64ShrU: opcode = [0x88]
        case .i64Rotl: opcode = [0x89]
        case .i64Rotr: opcode = [0x8A]
        case .f32Add: opcode = [0x92]
        case .f32Sub: opcode = [0x93]
        case .f32Mul: opcode = [0x94]
        case .f32Div: opcode = [0x95]
        case .f32Min: opcode = [0x96]
        case .f32Max: opcode = [0x97]
        case .f32Copysign: opcode = [0x98]
        case .f64Add: opcode = [0xA0]
        case .f64Sub: opcode = [0xA1]
        case .f64Mul: opcode = [0xA2]
        case .f64Div: opcode = [0xA3]
        case .f64Min: opcode = [0xA4]
        case .f64Max: opcode = [0xA5]
        case .f64Copysign: opcode = [0xA6]
        }

        try encodeInstruction(opcode)
    }
    mutating func visitConversion(_ conversion: Instruction.Conversion) throws(WasmKitError) {
        let opcode: [UInt8]
        switch conversion {
        case .i32WrapI64: opcode = [0xA7]
        case .i32TruncF32S: opcode = [0xA8]
        case .i32TruncF32U: opcode = [0xA9]
        case .i32TruncF64S: opcode = [0xAA]
        case .i32TruncF64U: opcode = [0xAB]
        case .i64ExtendI32S: opcode = [0xAC]
        case .i64ExtendI32U: opcode = [0xAD]
        case .i64TruncF32S: opcode = [0xAE]
        case .i64TruncF32U: opcode = [0xAF]
        case .i64TruncF64S: opcode = [0xB0]
        case .i64TruncF64U: opcode = [0xB1]
        case .f32ConvertI32S: opcode = [0xB2]
        case .f32ConvertI32U: opcode = [0xB3]
        case .f32ConvertI64S: opcode = [0xB4]
        case .f32ConvertI64U: opcode = [0xB5]
        case .f32DemoteF64: opcode = [0xB6]
        case .f64ConvertI32S: opcode = [0xB7]
        case .f64ConvertI32U: opcode = [0xB8]
        case .f64ConvertI64S: opcode = [0xB9]
        case .f64ConvertI64U: opcode = [0xBA]
        case .f64PromoteF32: opcode = [0xBB]
        case .i32ReinterpretF32: opcode = [0xBC]
        case .i64ReinterpretF64: opcode = [0xBD]
        case .f32ReinterpretI32: opcode = [0xBE]
        case .f64ReinterpretI64: opcode = [0xBF]
        case .i32TruncSatF32S: opcode = [0xFC, 0x00]
        case .i32TruncSatF32U: opcode = [0xFC, 0x01]
        case .i32TruncSatF64S: opcode = [0xFC, 0x02]
        case .i32TruncSatF64U: opcode = [0xFC, 0x03]
        case .i64TruncSatF32S: opcode = [0xFC, 0x04]
        case .i64TruncSatF32U: opcode = [0xFC, 0x05]
        case .i64TruncSatF64S: opcode = [0xFC, 0x06]
        case .i64TruncSatF64U: opcode = [0xFC, 0x07]
        }

        try encodeInstruction(opcode)
    }
    mutating func visitMemoryInit(dataIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x08])
        try encodeImmediates(dataIndex: dataIndex)
    }
    mutating func visitDataDrop(dataIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x09])
        try encodeImmediates(dataIndex: dataIndex)
    }
    mutating func visitMemoryCopy(dstMem: UInt32, srcMem: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x0A])
        try encodeImmediates(dstMem: dstMem, srcMem: srcMem)
    }
    mutating func visitMemoryFill(memory: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x0B])
        try encodeImmediates(memory: memory)
    }
    mutating func visitTableInit(elemIndex: UInt32, table: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x0C])
        try encodeImmediates(elemIndex: elemIndex, table: table)
    }
    mutating func visitElemDrop(elemIndex: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x0D])
        try encodeImmediates(elemIndex: elemIndex)
    }
    mutating func visitTableCopy(dstTable: UInt32, srcTable: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x0E])
        try encodeImmediates(dstTable: dstTable, srcTable: srcTable)
    }
    mutating func visitTableFill(table: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x11])
        try encodeImmediates(table: table)
    }
    mutating func visitTableGet(table: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x25])
        try encodeImmediates(table: table)
    }
    mutating func visitTableSet(table: UInt32) throws(WasmKitError) {
        try encodeInstruction([0x26])
        try encodeImmediates(table: table)
    }
    mutating func visitTableGrow(table: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x0F])
        try encodeImmediates(table: table)
    }
    mutating func visitTableSize(table: UInt32) throws(WasmKitError) {
        try encodeInstruction([0xFC, 0x10])
        try encodeImmediates(table: table)
    }
    mutating func visitAtomicFence() throws(WasmKitError) { try encodeInstruction([0xFE, 0x03, 0x00]) }
    mutating func visitMemoryAtomicNotify(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x00])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitMemoryAtomicWait32(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x01])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitMemoryAtomicWait64(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x02])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwAdd(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x1E])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwAdd(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x1F])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8AddU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x20])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16AddU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x21])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8AddU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x22])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16AddU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x23])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32AddU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x24])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwSub(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x25])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwSub(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x26])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8SubU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x27])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16SubU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x28])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8SubU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x29])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16SubU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x2A])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32SubU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x2B])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwAnd(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x2C])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwAnd(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x2D])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8AndU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x2E])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16AndU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x2F])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8AndU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x30])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16AndU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x31])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32AndU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x32])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwOr(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x33])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwOr(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x34])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8OrU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x35])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16OrU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x36])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8OrU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x37])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16OrU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x38])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32OrU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x39])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwXor(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x3A])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwXor(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x3B])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8XorU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x3C])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16XorU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x3D])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8XorU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x3E])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16XorU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x3F])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32XorU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x40])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwXchg(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x41])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwXchg(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x42])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8XchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x43])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16XchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x44])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8XchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x45])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16XchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x46])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32XchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x47])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmwCmpxchg(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x48])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmwCmpxchg(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x49])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw8CmpxchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x4A])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI32AtomicRmw16CmpxchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x4B])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw8CmpxchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x4C])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw16CmpxchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x4D])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitI64AtomicRmw32CmpxchgU(memarg: MemArg) throws(WasmKitError) {
        try encodeInstruction([0xFE, 0x4E])
        try encodeImmediates(memarg: memarg)
    }
    mutating func visitV128Const(value: V128) throws(WasmKitError) {
        try encodeInstruction([0xFD, 0x0C])
        try encodeImmediates(value: value)
    }
    mutating func visitI8x16Shuffle(lanes: V128ShuffleMask) throws(WasmKitError) {
        try encodeInstruction([0xFD, 0x0D])
        try encodeImmediates(lanes: lanes)
    }
    mutating func visitSimd(_ simd: Instruction.Simd) throws(WasmKitError) {
        let opcode: [UInt8]
        switch simd {
        case .i8x16Swizzle: opcode = [0xFD, 0x0E]
        case .i8x16Splat: opcode = [0xFD, 0x0F]
        case .i16x8Splat: opcode = [0xFD, 0x10]
        case .i32x4Splat: opcode = [0xFD, 0x11]
        case .i64x2Splat: opcode = [0xFD, 0x12]
        case .f32x4Splat: opcode = [0xFD, 0x13]
        case .f64x2Splat: opcode = [0xFD, 0x14]
        case .i8x16Eq: opcode = [0xFD, 0x23]
        case .i8x16Ne: opcode = [0xFD, 0x24]
        case .i8x16LtS: opcode = [0xFD, 0x25]
        case .i8x16LtU: opcode = [0xFD, 0x26]
        case .i8x16GtS: opcode = [0xFD, 0x27]
        case .i8x16GtU: opcode = [0xFD, 0x28]
        case .i8x16LeS: opcode = [0xFD, 0x29]
        case .i8x16LeU: opcode = [0xFD, 0x2A]
        case .i8x16GeS: opcode = [0xFD, 0x2B]
        case .i8x16GeU: opcode = [0xFD, 0x2C]
        case .i16x8Eq: opcode = [0xFD, 0x2D]
        case .i16x8Ne: opcode = [0xFD, 0x2E]
        case .i16x8LtS: opcode = [0xFD, 0x2F]
        case .i16x8LtU: opcode = [0xFD, 0x30]
        case .i16x8GtS: opcode = [0xFD, 0x31]
        case .i16x8GtU: opcode = [0xFD, 0x32]
        case .i16x8LeS: opcode = [0xFD, 0x33]
        case .i16x8LeU: opcode = [0xFD, 0x34]
        case .i16x8GeS: opcode = [0xFD, 0x35]
        case .i16x8GeU: opcode = [0xFD, 0x36]
        case .i32x4Eq: opcode = [0xFD, 0x37]
        case .i32x4Ne: opcode = [0xFD, 0x38]
        case .i32x4LtS: opcode = [0xFD, 0x39]
        case .i32x4LtU: opcode = [0xFD, 0x3A]
        case .i32x4GtS: opcode = [0xFD, 0x3B]
        case .i32x4GtU: opcode = [0xFD, 0x3C]
        case .i32x4LeS: opcode = [0xFD, 0x3D]
        case .i32x4LeU: opcode = [0xFD, 0x3E]
        case .i32x4GeS: opcode = [0xFD, 0x3F]
        case .i32x4GeU: opcode = [0xFD, 0x40]
        case .f32x4Eq: opcode = [0xFD, 0x41]
        case .f32x4Ne: opcode = [0xFD, 0x42]
        case .f32x4Lt: opcode = [0xFD, 0x43]
        case .f32x4Gt: opcode = [0xFD, 0x44]
        case .f32x4Le: opcode = [0xFD, 0x45]
        case .f32x4Ge: opcode = [0xFD, 0x46]
        case .f64x2Eq: opcode = [0xFD, 0x47]
        case .f64x2Ne: opcode = [0xFD, 0x48]
        case .f64x2Lt: opcode = [0xFD, 0x49]
        case .f64x2Gt: opcode = [0xFD, 0x4A]
        case .f64x2Le: opcode = [0xFD, 0x4B]
        case .f64x2Ge: opcode = [0xFD, 0x4C]
        case .v128Not: opcode = [0xFD, 0x4D]
        case .v128And: opcode = [0xFD, 0x4E]
        case .v128Andnot: opcode = [0xFD, 0x4F]
        case .v128Or: opcode = [0xFD, 0x50]
        case .v128Xor: opcode = [0xFD, 0x51]
        case .v128Bitselect: opcode = [0xFD, 0x52]
        case .i8x16Abs: opcode = [0xFD, 0x60]
        case .i8x16Neg: opcode = [0xFD, 0x61]
        case .i8x16AllTrue: opcode = [0xFD, 0x63]
        case .i8x16Bitmask: opcode = [0xFD, 0x64]
        case .i8x16NarrowI16X8S: opcode = [0xFD, 0x65]
        case .i8x16NarrowI16X8U: opcode = [0xFD, 0x66]
        case .i8x16Shl: opcode = [0xFD, 0x6B]
        case .i8x16ShrS: opcode = [0xFD, 0x6C]
        case .i8x16ShrU: opcode = [0xFD, 0x6D]
        case .i8x16Add: opcode = [0xFD, 0x6E]
        case .i8x16AddSatS: opcode = [0xFD, 0x6F]
        case .i8x16AddSatU: opcode = [0xFD, 0x70]
        case .i8x16Sub: opcode = [0xFD, 0x71]
        case .i8x16SubSatS: opcode = [0xFD, 0x72]
        case .i8x16SubSatU: opcode = [0xFD, 0x73]
        case .i8x16MinS: opcode = [0xFD, 0x76]
        case .i8x16MinU: opcode = [0xFD, 0x77]
        case .i8x16MaxS: opcode = [0xFD, 0x78]
        case .i8x16MaxU: opcode = [0xFD, 0x79]
        case .i8x16AvgrU: opcode = [0xFD, 0x7B]
        case .i16x8Abs: opcode = [0xFD, 0x80, 0x01]
        case .i16x8Neg: opcode = [0xFD, 0x81, 0x01]
        case .i16x8AllTrue: opcode = [0xFD, 0x83, 0x01]
        case .i16x8Bitmask: opcode = [0xFD, 0x84, 0x01]
        case .i16x8NarrowI32X4S: opcode = [0xFD, 0x85, 0x01]
        case .i16x8NarrowI32X4U: opcode = [0xFD, 0x86, 0x01]
        case .i16x8ExtendLowI8X16S: opcode = [0xFD, 0x87, 0x01]
        case .i16x8ExtendHighI8X16S: opcode = [0xFD, 0x88, 0x01]
        case .i16x8ExtendLowI8X16U: opcode = [0xFD, 0x89, 0x01]
        case .i16x8ExtendHighI8X16U: opcode = [0xFD, 0x8A, 0x01]
        case .i16x8Shl: opcode = [0xFD, 0x8B, 0x01]
        case .i16x8ShrS: opcode = [0xFD, 0x8C, 0x01]
        case .i16x8ShrU: opcode = [0xFD, 0x8D, 0x01]
        case .i16x8Add: opcode = [0xFD, 0x8E, 0x01]
        case .i16x8AddSatS: opcode = [0xFD, 0x8F, 0x01]
        case .i16x8AddSatU: opcode = [0xFD, 0x90, 0x01]
        case .i16x8Sub: opcode = [0xFD, 0x91, 0x01]
        case .i16x8SubSatS: opcode = [0xFD, 0x92, 0x01]
        case .i16x8SubSatU: opcode = [0xFD, 0x93, 0x01]
        case .i16x8Mul: opcode = [0xFD, 0x95, 0x01]
        case .i16x8MinS: opcode = [0xFD, 0x96, 0x01]
        case .i16x8MinU: opcode = [0xFD, 0x97, 0x01]
        case .i16x8MaxS: opcode = [0xFD, 0x98, 0x01]
        case .i16x8MaxU: opcode = [0xFD, 0x99, 0x01]
        case .i16x8AvgrU: opcode = [0xFD, 0x9B, 0x01]
        case .i32x4Abs: opcode = [0xFD, 0xA0, 0x01]
        case .i32x4Neg: opcode = [0xFD, 0xA1, 0x01]
        case .i32x4AllTrue: opcode = [0xFD, 0xA3, 0x01]
        case .i32x4Bitmask: opcode = [0xFD, 0xA4, 0x01]
        case .i32x4ExtendLowI16X8S: opcode = [0xFD, 0xA7, 0x01]
        case .i32x4ExtendHighI16X8S: opcode = [0xFD, 0xA8, 0x01]
        case .i32x4ExtendLowI16X8U: opcode = [0xFD, 0xA9, 0x01]
        case .i32x4ExtendHighI16X8U: opcode = [0xFD, 0xAA, 0x01]
        case .i32x4Shl: opcode = [0xFD, 0xAB, 0x01]
        case .i32x4ShrS: opcode = [0xFD, 0xAC, 0x01]
        case .i32x4ShrU: opcode = [0xFD, 0xAD, 0x01]
        case .i32x4Add: opcode = [0xFD, 0xAE, 0x01]
        case .i32x4Sub: opcode = [0xFD, 0xB1, 0x01]
        case .i32x4Mul: opcode = [0xFD, 0xB5, 0x01]
        case .i32x4MinS: opcode = [0xFD, 0xB6, 0x01]
        case .i32x4MinU: opcode = [0xFD, 0xB7, 0x01]
        case .i32x4MaxS: opcode = [0xFD, 0xB8, 0x01]
        case .i32x4MaxU: opcode = [0xFD, 0xB9, 0x01]
        case .i32x4DotI16X8S: opcode = [0xFD, 0xBA, 0x01]
        case .i64x2Abs: opcode = [0xFD, 0xC0, 0x01]
        case .i64x2Neg: opcode = [0xFD, 0xC1, 0x01]
        case .i64x2Bitmask: opcode = [0xFD, 0xC4, 0x01]
        case .i64x2ExtendLowI32X4S: opcode = [0xFD, 0xC7, 0x01]
        case .i64x2ExtendHighI32X4S: opcode = [0xFD, 0xC8, 0x01]
        case .i64x2ExtendLowI32X4U: opcode = [0xFD, 0xC9, 0x01]
        case .i64x2ExtendHighI32X4U: opcode = [0xFD, 0xCA, 0x01]
        case .i64x2Shl: opcode = [0xFD, 0xCB, 0x01]
        case .i64x2ShrS: opcode = [0xFD, 0xCC, 0x01]
        case .i64x2ShrU: opcode = [0xFD, 0xCD, 0x01]
        case .i64x2Add: opcode = [0xFD, 0xCE, 0x01]
        case .i64x2Sub: opcode = [0xFD, 0xD1, 0x01]
        case .i64x2Mul: opcode = [0xFD, 0xD5, 0x01]
        case .f32x4Ceil: opcode = [0xFD, 0x67]
        case .f32x4Floor: opcode = [0xFD, 0x68]
        case .f32x4Trunc: opcode = [0xFD, 0x69]
        case .f32x4Nearest: opcode = [0xFD, 0x6A]
        case .f64x2Ceil: opcode = [0xFD, 0x74]
        case .f64x2Floor: opcode = [0xFD, 0x75]
        case .f64x2Trunc: opcode = [0xFD, 0x7A]
        case .f64x2Nearest: opcode = [0xFD, 0x94, 0x01]
        case .f32x4Abs: opcode = [0xFD, 0xE0, 0x01]
        case .f32x4Neg: opcode = [0xFD, 0xE1, 0x01]
        case .f32x4Sqrt: opcode = [0xFD, 0xE3, 0x01]
        case .f32x4Add: opcode = [0xFD, 0xE4, 0x01]
        case .f32x4Sub: opcode = [0xFD, 0xE5, 0x01]
        case .f32x4Mul: opcode = [0xFD, 0xE6, 0x01]
        case .f32x4Div: opcode = [0xFD, 0xE7, 0x01]
        case .f32x4Min: opcode = [0xFD, 0xE8, 0x01]
        case .f32x4Max: opcode = [0xFD, 0xE9, 0x01]
        case .f32x4Pmin: opcode = [0xFD, 0xEA, 0x01]
        case .f32x4Pmax: opcode = [0xFD, 0xEB, 0x01]
        case .f64x2Abs: opcode = [0xFD, 0xEC, 0x01]
        case .f64x2Neg: opcode = [0xFD, 0xED, 0x01]
        case .f64x2Sqrt: opcode = [0xFD, 0xEF, 0x01]
        case .f64x2Add: opcode = [0xFD, 0xF0, 0x01]
        case .f64x2Sub: opcode = [0xFD, 0xF1, 0x01]
        case .f64x2Mul: opcode = [0xFD, 0xF2, 0x01]
        case .f64x2Div: opcode = [0xFD, 0xF3, 0x01]
        case .f64x2Min: opcode = [0xFD, 0xF4, 0x01]
        case .f64x2Max: opcode = [0xFD, 0xF5, 0x01]
        case .f64x2Pmin: opcode = [0xFD, 0xF6, 0x01]
        case .f64x2Pmax: opcode = [0xFD, 0xF7, 0x01]
        case .i32x4TruncSatF32X4S: opcode = [0xFD, 0xF8, 0x01]
        case .i32x4TruncSatF32X4U: opcode = [0xFD, 0xF9, 0x01]
        case .f32x4ConvertI32X4S: opcode = [0xFD, 0xFA, 0x01]
        case .f32x4ConvertI32X4U: opcode = [0xFD, 0xFB, 0x01]
        case .i16x8ExtmulLowI8X16S: opcode = [0xFD, 0x9C, 0x01]
        case .i16x8ExtmulHighI8X16S: opcode = [0xFD, 0x9D, 0x01]
        case .i16x8ExtmulLowI8X16U: opcode = [0xFD, 0x9E, 0x01]
        case .i16x8ExtmulHighI8X16U: opcode = [0xFD, 0x9F, 0x01]
        case .i32x4ExtmulLowI16X8S: opcode = [0xFD, 0xBC, 0x01]
        case .i32x4ExtmulHighI16X8S: opcode = [0xFD, 0xBD, 0x01]
        case .i32x4ExtmulLowI16X8U: opcode = [0xFD, 0xBE, 0x01]
        case .i32x4ExtmulHighI16X8U: opcode = [0xFD, 0xBF, 0x01]
        case .i64x2ExtmulLowI32X4S: opcode = [0xFD, 0xDC, 0x01]
        case .i64x2ExtmulHighI32X4S: opcode = [0xFD, 0xDD, 0x01]
        case .i64x2ExtmulLowI32X4U: opcode = [0xFD, 0xDE, 0x01]
        case .i64x2ExtmulHighI32X4U: opcode = [0xFD, 0xDF, 0x01]
        case .i16x8Q15MulrSatS: opcode = [0xFD, 0x82, 0x01]
        case .v128AnyTrue: opcode = [0xFD, 0x53]
        case .i64x2Eq: opcode = [0xFD, 0xD6, 0x01]
        case .i64x2Ne: opcode = [0xFD, 0xD7, 0x01]
        case .i64x2LtS: opcode = [0xFD, 0xD8, 0x01]
        case .i64x2GtS: opcode = [0xFD, 0xD9, 0x01]
        case .i64x2LeS: opcode = [0xFD, 0xDA, 0x01]
        case .i64x2GeS: opcode = [0xFD, 0xDB, 0x01]
        case .i64x2AllTrue: opcode = [0xFD, 0xC3, 0x01]
        case .f64x2ConvertLowI32X4S: opcode = [0xFD, 0xFE, 0x01]
        case .f64x2ConvertLowI32X4U: opcode = [0xFD, 0xFF, 0x01]
        case .i32x4TruncSatF64X2SZero: opcode = [0xFD, 0xFC, 0x01]
        case .i32x4TruncSatF64X2UZero: opcode = [0xFD, 0xFD, 0x01]
        case .f32x4DemoteF64X2Zero: opcode = [0xFD, 0x5E]
        case .f64x2PromoteLowF32X4: opcode = [0xFD, 0x5F]
        case .i8x16Popcnt: opcode = [0xFD, 0x62]
        case .i16x8ExtaddPairwiseI8X16S: opcode = [0xFD, 0x7C]
        case .i16x8ExtaddPairwiseI8X16U: opcode = [0xFD, 0x7D]
        case .i32x4ExtaddPairwiseI16X8S: opcode = [0xFD, 0x7E]
        case .i32x4ExtaddPairwiseI16X8U: opcode = [0xFD, 0x7F]
        }

        try encodeInstruction(opcode)
    }
    mutating func visitSimdLane(_ simdLane: Instruction.SimdLane, lane: UInt8) throws(WasmKitError) {
        let opcode: [UInt8]
        switch simdLane {
        case .i8x16ExtractLaneS: opcode = [0xFD, 0x15]
        case .i8x16ExtractLaneU: opcode = [0xFD, 0x16]
        case .i8x16ReplaceLane: opcode = [0xFD, 0x17]
        case .i16x8ExtractLaneS: opcode = [0xFD, 0x18]
        case .i16x8ExtractLaneU: opcode = [0xFD, 0x19]
        case .i16x8ReplaceLane: opcode = [0xFD, 0x1A]
        case .i32x4ExtractLane: opcode = [0xFD, 0x1B]
        case .i32x4ReplaceLane: opcode = [0xFD, 0x1C]
        case .i64x2ExtractLane: opcode = [0xFD, 0x1D]
        case .i64x2ReplaceLane: opcode = [0xFD, 0x1E]
        case .f32x4ExtractLane: opcode = [0xFD, 0x1F]
        case .f32x4ReplaceLane: opcode = [0xFD, 0x20]
        case .f64x2ExtractLane: opcode = [0xFD, 0x21]
        case .f64x2ReplaceLane: opcode = [0xFD, 0x22]
        }

        try encodeInstruction(opcode)
        try encodeImmediates(lane: lane)
    }
    mutating func visitSimdMemLane(_ simdMemLane: Instruction.SimdMemLane, memarg: MemArg, lane: UInt8) throws(WasmKitError) {
        let opcode: [UInt8]
        switch simdMemLane {
        case .v128Load8Lane: opcode = [0xFD, 0x54]
        case .v128Load16Lane: opcode = [0xFD, 0x55]
        case .v128Load32Lane: opcode = [0xFD, 0x56]
        case .v128Load64Lane: opcode = [0xFD, 0x57]
        case .v128Store8Lane: opcode = [0xFD, 0x58]
        case .v128Store16Lane: opcode = [0xFD, 0x59]
        case .v128Store32Lane: opcode = [0xFD, 0x5A]
        case .v128Store64Lane: opcode = [0xFD, 0x5B]
        }

        try encodeInstruction(opcode)
        try encodeImmediates(memarg: memarg, lane: lane)
    }
}
